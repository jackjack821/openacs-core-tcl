<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Creating Web Pages</title><meta name="generator" content="DocBook XSL Stylesheets V1.50.0"><link rel="home" href="index.html" title="OpenACS Documentation"><link rel="up" href="tutorial.html" title="Chapter 8. Development Tutorial"><link rel="previous" href="tutorial-database.html" title="Setting Up Database Objects"><link rel="next" href="tutorial-debug.html" title="Debugging and Automated Testing"><link rel="stylesheet" href="openacs.css" type="text/css"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><a href="http://openacs.org"><img src="images/alex.jpg" border="0"></a><table width="100%" summary="Navigation header" border="0"><tr><td width="20%" align="left"><a accesskey="p" href="tutorial-database.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter 8. Development Tutorial</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="tutorial-debug.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="tutorial-pages"></a>Creating Web Pages</h2></div></div><div class="authorblurb"><p>
    by <a href="mailto:joel@aufrecht.org" target="_top">Joel Aufrecht</a><br>
          OpenACS docs are written by the named authors, but may be edited
          by OpenACS documentation staff.
        </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2854383"></a>Build the &quot;Index&quot; page</h3></div></div><p>Each user-visible page in your package has, typically,
      three parts.  The <tt>xql</tt> file contains any database queries, the
      <tt>tcl</tt> file holds the procedural logic for the page and does things
      like check permissions, invoke the database queries, and modify
      variables, and the <tt>adp</tt> page
      holds html.  The default page in any directory is
      <tt>index</tt>, so we'll build that
      first, starting with the tcl file:
</p><pre class="screen">[service0@yourserver samplenote]$<b><tt> cd /web/service0/packages/samplenote/www</tt></b>
[service0@yourserver www]$ <b><tt>emacs index.tcl</tt></b></pre><p>Paste this into the file.  There are several things to
note about the file:</p><div class="itemizedlist"><ul type="disc"><li><p>The page begins with an
        <tt><a href="/api-doc/proc-view?proc=ad%5fpage%5fcontract" target="_top">ad_page_contract</a></tt> function.
        This is where we declare the input and output variables and
        their types and restrictions.  It's also where we document the
        page, including descriptions of the parameters and return.</p></li><li><p>We have one input variable,
          <tt>orderby</tt>, which is optional
          and defaults to <tt>title</tt>.</p></li><li><p>We have one output variable, <tt>table_html</tt></p></li><li><p>We populate the table_html variable with a function call, <tt><a href="/api-doc/proc-view?proc=ad%5f_table" target="_top">ad_table</a></tt>, which does most of the work of generating an html table from a database recordset.  We pass it several parameters:</p><div class="variablelist"><dl><dt><span class="term">-Torderby $orderby</span></dt><dd><p>If the user has selected a column for sorting, this passes that information to the function.</p></dd><dt><span class="term">notes_query</span></dt><dd><p>This is the name of the SQL query that we'll put in the xql file.</p></dd><dt><span class="term">{ *SQL* }</span></dt><dd><p>This is a dummy placeholder.  It's possible to put sql directly in the tcl file, but this is deprecated because it's harder to make portable.</p></dd><dt><span class="term">$table_def</span></dt><dd><p>Here we pass in the variable we just constructed; it contains a list of column names and display titles.</p></dd></dl></div></li></ul></div><pre class="programlisting">ad_page_contract {
    This is the main page for the package.  It displays all of the Sample Notes\ and provides links to edit them and to create new Notes.

    @author rhs@mit.edu
    @creation-date 2000-10-23
    @cvs-id $Id$
    @param orderby indicates when the user clicks on a column to order by that \column
    @return table_html preformatting html table constructed by querying the sam\plenotes table

} {
    {orderby:optional {title}}
} -properties {
    table_html
}
# define the columns in the table
set table_def   {
    {title &quot;Note&quot;}
    {body &quot;Contents&quot;}
    {edit &quot;&quot; {} {&lt;td&gt;&lt;a href=&quot;note-edit?note_id=$note_id&quot;&gt;Edit&lt;/a&gt;&lt;/td&gt;}}
    {delete &quot;&quot; {} {&lt;td&gt;&lt;a href=&quot;note-delete?note_id=$note_id&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;}}
}

# construct an html table from the samplenotes database table
set table_html [ad_table -Torderby $orderby notes_query { *SQL* } $table_def]</pre><p>Now put the database query into a separate file.  If the
      database query is exactly the same for Oracle and PostgreSQL, it
      can go into a file with the same name as the tcl file but an xql
      extension, e.g., <tt>index.xql</tt>.  If
      it is database-specific, it goes in
      <tt>index-oracle.xql</tt> or
      <tt>index-postgresql.xql</tt>.  The
      format is the same in each case, an XML structure that contains
      the SQL query.  Create the file now.</p><pre class="screen">[service0@yourserver www]$<b><tt> emacs index.xql</tt></b></pre><p>Note that the
      <tt>name</tt> parameter of the
      <tt>fullquery</tt> tag exactly matches
      the SQL query name specified in the
      <tt>ad_table</tt> call.  Also, the SQL query ends with a tcl function call that generates a SQL ORDER BY clause using several TCL variables.  </p><pre class="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;queryset&gt;
  &lt;fullquery name=&quot;notes_query&quot;&gt;
    &lt;querytext&gt;
    select note_id,
           title,
           body
      from samplenote
    [ad_order_by_from_sort_spec $orderby $table_def]
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</pre><p>Now we create the user-visible page.</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs index.adp</tt></b></pre><p>The first line indicates that this page should be rendered within the the master template, which defaults to <tt>/web/service0/www/default-master</tt>.  The second line passes a <tt>title</tt> variable to the master template.  The third line inserts the contents of the variable <tt>table_html</tt>.  The last line is a link to a page we haven't created yet.</p><pre class="programlisting">&lt;master&gt;
&lt;property name=&quot;title&quot;&gt;Sample Notes&lt;/property&gt;
@table_html@
&lt;p&gt;&lt;a href=&quot;note-edit&quot;&gt;Add a note&lt;/a&gt;&lt;/p&gt;</pre></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2854887"></a>Add files to APM</h3></div></div><p>Before we can test these files, we have to notify the package manager that they exist.  (To be precise, the tcl and adp will work fine as-is, but the xql file will not be recognized until we tell the APM about it.).</p><div class="itemizedlist"><ul type="disc"><li><p> Go to <tt>http://yourserver.test:8000/acs-admin/apm</tt></p></li><li><p>Click on the <tt>samplenote</tt> link</p></li><li><p>Click <tt>Manage file information</tt></p></li><li><p>Click <tt>Scan the packages/samplenote directory for additional files in thispackage </tt></p></li><li><p>Click <tt>add checked files</tt></p></li></ul></div><p>Now that the pages are in the APM, check to make sure that the self-documenting code is working.</p><div class="itemizedlist"><ul type="disc"><li><p>Browse to <tt>http://yourserver:8000/api-doc/</tt></p></li><li><p>Click <tt># Notes (Sample Application) 0.1d</tt></p></li><li><p>Click <tt>Content Pages</tt></p></li><li><p>Click <tt>index.tcl</tt> and examine the results.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2855038"></a>Test the index page</h3></div></div><p>Go to <tt>http://192.168.0.2:8000/samplenote/</tt>.  You should see something like this:</p><pre class="screen">
Sample Notes
Your Workspace : Main Site : Sample Note 

No data found.

foo@yourserver.test
</pre><p>Since our table is empty, it's a pretty boring page.  So next we'll make it possible to add records. </p><p>If you get any other output, such as an error message, skip to <a href="tutorial-debug.html" title="Debugging and Automated Testing">the section called &#8220;Debugging and Automated Testing&#8221;</a>.  Note also that, while tcl and adp pages update automatically, xql pages get cached.  So if you change an xql page, the change won't take effect unless you restart the server, reload the package via the APM, or put a <span class="emphasis"><em>watch</em></span> on the file in the APM file list.  With a watch, which lasts until the next service restart, the file will be updated each time it is changed on disk.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2855099"></a>Add the add/edit page</h3></div></div><p>We'll create a single page to handle both adding and editing records.  First, create the tcl:</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs note-edit.tcl</tt></b></pre><p>The page takes a single, optional input parameter, note_id.  If it's present, logic within <tt><a href="/api-doc/proc-view?proc=ad_form" target="_top">ad_form</a></tt> will assume that we're editing an existing record.  We check user_id with <tt><a href="/api-doc/proc-view?proc=ad_maybe_redirect_for_registration" target="_top">ad_maybe_redirect_for_registration</a></tt>, which will redirect to the login page (with an automatic return path to bring them back after login or registration) if the visitor isn't logged in.  Then we call ad_form, specifying the primary key of the table, the fields we want to edit, and functions for insert and update.</p><pre class="programlisting">ad_page_contract {
        Simple add/edit form for samplenote.
} {
    note_id:optional
}
set user_id [ad_maybe_redirect_for_registration]

ad_form -name note -form {
    note_id:key
    {title:text
        {label &quot;Title&quot;}
    }
    {body:text(textarea)
        {label &quot;Body&quot;}
    }
} -select_query_name note_query -new_data {
db_1row do_insert { *SQL* }
} -edit_data {
db_dml do_update { *SQL* }
} -after_submit {
ad_returnredirect &quot;index&quot;
ad_script_abort
}</pre><p>Next, we create the database functions.</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs note-edit.xql</tt></b></pre><pre class="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;queryset&gt;
  &lt;fullquery name=&quot;do_insert&quot;&gt;
    &lt;querytext&gt;
        select samplenote__new(:title, :body,null,:user_id,null,null)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name=&quot;do_update&quot;&gt;
    &lt;querytext&gt;
       update samplenote
          set title = :title,
              body = :body
        where note_id = :note_id
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name=&quot;note_query&quot;&gt;
    &lt;querytext&gt;
      select title,
             body
        from samplenote
       where note_id = :note_id
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</pre><p>And now the user-visible page:</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs note-edit.adp</tt></b></pre><pre class="programlisting">&lt;master&gt;
&lt;formtemplate id=&quot;note&quot;&gt;&lt;/formtemplate&gt;
</pre><p>Go to the APM as before and scan for new files and add your new work.  Then test all this by going to the package home page and adding and editing a few records.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2855244"></a>A Deletion page</h3></div></div><p>Now we need a way to delete records.  We'll create a recursive confirmation page.</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs note-delete.tcl</tt></b></pre><p>This page requires a <tt>note_id</tt> to determine which record should be deleted.  It also looks for a confirmation variable, which should initially be absert.  If it is absent, we create a form to allow the user to confirm the deletion.  The form calls the same page, but with hidden variables carrying both <tt>note_id</tt> and <tt>confirm_p</tt>.</p><pre class="programlisting">ad_page_contract {
    A page that gets confirmation and then delete notes.

    @author joel@aufrecht.org
    @creation-date 2003-02-12
    @cvs-id $Id$
} {
    note_id:integer
    confirm_p:optional
}

set title &quot;Delete Note&quot;

if {[exists_and_not_null confirm]} {
    # if confirmed, call the database to delete the record
    db_1row do_delete { *SQL* }
    ad_returnredirect &quot;index&quot;
} else {
    # if not confirmed, display a form for confirmation
    set note_name [db_string get_name { *SQL }]
    set title &quot;Delete $note_name&quot;
    template::form::create note-del-confirm
    template::element::create note-del-confirm note_id -value $note_id -widget \hidden
    template::element::create note-del-confirm confirm_p -value 1 -widget hidden
}</pre><p>Now the database calls:</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs note-delete.xql</tt></b></pre><pre class="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;queryset&gt;
  &lt;fullquery name=&quot;do_delete&quot;&gt;
    &lt;querytext&gt;
      select samplenote__delete(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name=&quot;get_name&quot;&gt;
    &lt;querytext&gt;
      select samplenote__name(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</pre><p>And the adp page:</p><pre class="screen">[service0@yourserver www]$ <b><tt>emacs note-delete.adp</tt></b></pre><pre class="programlisting">&lt;master&gt;
&lt;property name=&quot;title&quot;&gt;@title@&lt;/property&gt;
&lt;h2&gt;@title@&lt;/h2&gt;
&lt;formtemplate id=&quot;note-del-confirm&quot;&gt;&lt;/formtemplate&gt;
&lt;/form&gt;</pre><p>Now test it by adding the new files in the APM and then deleting a few samplenotes.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2855384"></a>Adding files to cvs</h3></div></div><p>Put your new work into source control.</p><pre class="screen">[service0@yourserver www]$ <b><tt>cvs add *.adp *.tcl *.xql</tt></b>
cvs add: cannot add special file `CVS'; skipping
cvs add: doc/CVS already exists
cvs add: scheduling file `index.adp' for addition
cvs add: scheduling file `index.tcl' for addition
cvs add: scheduling file `index.xql' for addition
cvs add: scheduling file `note-delete.adp' for addition
cvs add: scheduling file `note-delete.tcl' for addition
cvs add: scheduling file `note-delete.xql' for addition
cvs add: scheduling file `note-edit.adp' for addition
cvs add: scheduling file `note-edit.tcl' for addition
cvs add: scheduling file `note-edit.xql' for addition
cvs add: use 'cvs commit' to add these files permanently
[service0@yourserver www]$ <b><tt> cvs commit -m &quot;new work&quot;</tt></b>
/cvsroot/service0/packages/samplenote/www/note-edit.xql~,v  &lt;--  note-edit.xql
<span class="emphasis"><em>(many lines omitted)</em></span>
initial revision: 1.1
done
[service0@yourserver www]$</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial-database.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="tutorial-debug.html">Next</a></td></tr><tr><td width="40%" align="left">Setting Up Database Objects&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="tutorial.html">Up</a></td><td width="40%" align="right">&nbsp;Debugging and Automated Testing</td></tr></table><hr><address>rmello at fslc.usu.edu</address><address><a href="mailto:vinod@kurup.com">vinod@kurup.com</a></address></div><a name="comments"></a><center><a href="http://openacs.org/doc/openacs-4/tutorial-pages.html#comments">View comments on this page at openacs.org</a></center></body></html>
