<?xml version='1.0' ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY % myvars SYSTEM "../variables.ent">
%myvars;
]>
<sect1 id="i18n">
  <title>Internationalization</title>

  <authorblurb>
    <para>
      By <ulink url="http://www.petermarklund.com/">Peter Marklund</ulink>
      and <ulink url="http://www.pinds.com/">Lars Pind</ulink>
    </para>
  </authorblurb>

  <sect2 id="i18n-introduction">

    <title>Introduction</title>

    <para>
      This document describes how to develop internationalized OpenACS
      packages, including writing new packages with
      internationalization and converting old packages.  Text that
      users might see is "localizable text"; replacing monolingual text
      and single-locale date/time/money functions with generic
      functions is "internationalization"; translating first
      generation text into a specific language is "localization."  At
      a minimum, all packages should be internationalized.  If you do
      not also localize your package for different locales, volunteers
      may use a public "localization server" to submit suggested text.
      Otherwise, your package will not be usable for all locales.
    </para>

    <para>
      The main difference between monolingual and internationalized
      packages is that all user-visible text in an internationalized
      package are coded as "message keys."  The message keys
      correspond to a message catalog, which contains versions of the
      text for each available language.  Both script files
      (ADP/TCL) and APM parameters are affected.
    </para>

    <para>
      Other differences include: all dates read or written to the
      database must use internationalized functions.  All displayed
      dates must use internationalized functions.  All displayed
      numbers must use internationalized functions.
</para>

  </sect2>

  <sect2 id="i18n-message-catalog">

    <title>Using the Message Catalog</title>

    <para>
      Localizable text must be handled in ADP files, in TCL files, and
      in APM Parameters.  OpenACS provides two approaches, message
      keys and localized ADP files.  For ADP pages which are mostly
      code, replacing the message text with message key placeholders
      is simpler.  This approach also allows new translation in the
      database, without affecting the file system.  For ADP pages
      which are static and mostly text, it may be easier to create a
      new ADP page for each language.  In this case, the pages are
      distinguished by a file naming convention.
    </para>


    <sect3>
      <title>Separate Templates for each Locale</title>
      <para>If the request processor finds a file named <computeroutput>filename.locale.adp</computeroutput>, where locale matches the user's locale, it will process that file instead of <computeroutput>filename.adp</computeroutput>.  For example, for a user with locale <computeroutput>tl_PH</computeroutput>, the file <computeroutput>index.tl_PH.adp</computeroutput>, if found, will be used instead of <computeroutput>index.adp</computeroutput>.  The locale-specific file should thus contain text in the language appropriate for that locale.  The code in the page, however, should still be in English.  Message keys are still processed.</para>

    </sect3>

    <sect3 id="i18n-message-catalog-adps">
      <title>Message Keys in Template Files (ADP Files)</title>

      <para>
        Internationalizing templates is about replacing human readable
        text in a certain language with internal message keys, which
        can then be dynamically replaced with real human language in
        the desired locale.  Message keys themselves should be in
        ASCII English, as should all code.  Three different syntaxes
        are possible for message keys.
      </para>
      
      <para>
        "Short" syntax is the recommended syntax and should be used
        for new development.  When internationalizing an existing
        package, you can use the "temporary" syntax, which the APM can
        use to auto-generate missing keys and automatically translate
        to the short syntax.  The "verbose" syntax is useful while
        developing, because it allows default text so that the page is
        usable before you have done
        localization.      </para>
      
      <itemizedlist>

        <listitem>
          <para>
            The <emphasis role="strong">short</emphasis>:
            <computeroutput>#<emphasis>package_key.message_key</emphasis>#</computeroutput>
          </para>
          <para>
            The advantage of the short syntax is that it's short. It's
            as simple as inserting the value of a variable.  Example:
            <emphasis>#forum.title#</emphasis>
          </para>
        </listitem>

        <listitem>
          <para>
            The <emphasis role="strong">verbose</emphasis>: <computeroutput>&lt;trn
            key="<emphasis>package_key.message_key</emphasis>"
            locale="<emphasis>locale</emphasis>"&gt;<emphasis>default
            text</emphasis>&lt;/trn&gt;</computeroutput>
          </para>
          <para>
            The verbose syntax allows you to specify a default text in
            a certain language. This syntax is not recommended
            anymore, but it can be convenient for development, because
            it still works even if you haven't created the message
            in the message catalog yet, because what it'll do is
            create the message key with the default text from the tag
            as the localized message.  Example: <emphasis>&lt;trn
            key="forum.title" locale="en_US"&gt;Title&lt;/trn&gt;</emphasis>
          </para>
        </listitem>

        <listitem>
          <para>
            The <emphasis role="strong">temporary</emphasis>:
           <computeroutput> &lt;#<emphasis>message_key</emphasis>
           <emphasis>original text</emphasis>#&gt;</computeroutput>
          </para>
          <para>
            This syntax has been designed to make it easy to
            internationalize existing pages. This is not a syntax that
            stays in the page. As you'll see later, it'll be replaced
            with the short syntax by a special feature of the APM. You
            may leave out the message_key by writing an underscore (_)
            character instead, in which case a message key will be
            auto-generated by the APM.  Example: <emphasis>&lt;_ Title&gt;</emphasis>
          </para>
        </listitem>

      </itemizedlist>

      <para>
        We recommend the short notation for new package development.
      </para>
      
    </sect3>

    <sect3 id="i18n-message-catalog-params" xreflabel="Multilingual APM Parameters">

      <title>APM Parameters</title>

      <para>
        Some parameters contain text that need to be localized. In
        this case, instead of storing the real text in the parameter,
        you should use message keys using the short notation above,
        i.e.  <emphasis
        role="strong">#<emphasis>package_key.message_key</emphasis>#</emphasis>.
      </para>

      <para>
       In order to avoid clashes with other uses of the hash
         character, you need to tell the APM that the parameter value
         needs to be localized when retrieving it. You do that by saying:
         <emphasis role="strong">parameter::get -localize</emphasis>.
      </para>

      <para>
        Here are a couple of examples. Say we have the following two
        parameters, taken directly from the dotlrn package.
      </para>

      <table frame="all">
        <tgroup cols="2" colsep="1" rowsep="1">
          <colspec colname="c1"/>
          <colspec colname="c2"/>
          <thead>
            <row>
              <entry>Parameter Name</entry>
              <entry>Parameter Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
               <entry>class_instance_pages_csv</entry>
               <entry>#dotlrn.class_page_home_title#,Simple 2-Column;#dotlrn.class_page_calendar_title#,Simple 1-Column;#dotlrn.class_page_file_storage_title#,Simple 1-Column</entry>
            </row>
            <row>
               <entry>departments_pretty_name</entry>
               <entry>#departments_pretty_name#</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
        Then, depending on how we retrieve the value, here's what we get:
      </para>
  
      <table frame="all">
        <tgroup cols="2" colsep="1" rowsep="1">
          <colspec colname="c1"/>
          <colspec colname="c2"/>
          <thead>
            <row>
              <entry>Command used to retrieve Value</entry>
              <entry>Retrieved Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
               <entry>parameter::get <emphasis role="strong">-localize</emphasis> -parameter class_instances_pages_csv</entry>
               <entry>Kurs Startseite,Simple 2-Column;Kalender,Simple 1-Column;Dateien,Simple 1-Column</entry>
            </row>
            <row>
               <entry>parameter::get <emphasis role="strong">-localize</emphasis> -parameter departments_pretty_name</entry>
               <entry>Abteilung</entry>
            </row>
            <row>
               <entry>parameter::get -parameter departments_pretty_name</entry>
               <entry>#departments_pretty_name#</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
  
      <para>
        The value in the rightmost column in the table above is the
        value returned by an invocation of parameter::get. Note that
        for localization to happen you must use the -localize flag.
      </para>
      
      <para>
        The locale used for the message lookup will be the locale of
        the current request, i.e. lang::conn::locale or ad_conn
        locale.
      </para>
      
      <para>
        Developers are responsible for creating the keys in the message
        catalog, which is available at <computeroutput>/acs-lang/admin/</computeroutput>
      </para>

    </sect3>

  </sect2>


  <sect2 id="i18n-date-time-number">

    <title>Dates, Times, and Numbers</title>

    <para>
      Dates and times must be converted when stored in the database,
      when retrieved from the database, and when displayed.  All dates
      are stored in the database in the server's timezone, which is an
      APM Parameter set at
      <computeroutput>/acs-lang/admin/set-system-timezone</computeroutput>
      and readable at
      <computeroutput>lang::system::timezone.</computeroutput>.  When
      retrieved from the database and displayed, dates and times must
      be localized to the user's locale.
    </para>

    <orderedlist>

      <listitem>
        <para>
          Get the date in ANSI format from the database (YYYY-MM-DD
          HH24:MI:SS; the time portion is optional).  By convention,
          we identify dates in ansi format by ending the column name
          with <computeroutput>_ansi</computeroutput>.
          Example:</para>
        <programlisting>select to_char(posting_date, 'YYYY-MM-DD HH24:MI:SS') as posting_date_ansi
  from table
</programlisting>
      </listitem>

      <listitem>
        <para>
          Use the Tcl command <computeroutput>lc_time_fmt</computeroutput> to format the
          date in "pretty" format.  Several standard formats localize automatically:
</para>
    <itemizedlist>

      <listitem>
        <para>
          %c: Long date and time (Mon November 18, 2002 12:00 AM)
        </para>
      </listitem>

      <listitem>
        <para>
          %x: Short date (11/18/02)
        </para>
      </listitem>

      <listitem>
        <para>
          %X: Time (12:00 AM)
        </para>
      </listitem>

      <listitem>
        <para>
          %q: Long date without weekday (November 18, 2002)
        </para>
      </listitem>

      <listitem>
        <para>
           %Q: Long date with weekday (Monday November 18, 2002)
        </para>
      </listitem>

    </itemizedlist>

        <para>
      The "q" format strings are OpenACS additions; the rest follow unix standards (see <computeroutput>man
      strftime</computeroutput>).
    </para>
        
        <programlisting>set posting_date_pretty [lc_time_fmt $posting_date_ansi &quot;%q&quot;]</programlisting>
        
      </listitem>
      
      <listitem>
        <para>
          Use the <computeroutput>*_pretty</computeroutput> version in your ADP page.
        </para>
      </listitem>
      
    </orderedlist>

    <para>
      To internationalize numbers, use <computeroutput>lc_numeric $value</computeroutput>, which formats the number using the appropriate decimal point and thousand separator for the locale.
    </para>
    
  </sect2>

  <sect2 id="i18n-forms">
    <title>Internationalizing Forms</title>
    <para>When coding forms, remember to use message keys for each piece of text that is user-visible, including form option labels and button labels.</para>
  </sect2>

  <sect2 id="i18n-convert">

    <title>Internationalizing Existing Packages</title>

    <sect3>
        <title>Internationalize Message text in ADP and TCL</title>

        <para>Acs-lang includes tools to automate some
        internationalization.  From
        <computeroutput>/acs-admin/apm/</computeroutput>, select a
        package and then click on
        <computeroutput>Internationalization</computeroutput>, then
        <computeroutput>Convert ADP, Tcl, and SQL files to using the
        message catalog.</computeroutput>.</para>
        <orderedlist>
          <listitem>
            <para>
            <emphasis role="strong">Replace text with tags</emphasis>:
            Choose <computeroutput>Find human language text and replace with &lt;# ... #&gt; tags</computeroutput>.  This automated process
            automatically locates chunks of translatable text,
            generates a reasonable message key, and replaces the text
            with a "temporary" tag as described above.
          </para>
          <para>Any pieces of text found but not extractable -- for
          example, pieces of text with embedded adp variables
          (i.e. @var_name@) --  will be listed on the result
          page. Make sure to take note of these texts and translate
          them manually. Suppose for example that our script tells you
          that it left the text "Manage forum @forum_name@"
          untouched. What you should do then is to edit the
          corresponding adp file and manually replace that text with
          something like "&lt;#manage_forum Manage forum @forum_name@#&gt;"
          (to save you from too much typing you may use the shorthand
          &lt;#_ Manage forum @forum_name@#&gt;; an underscore key will
          result in the script auto-generating a key for you based on
          the text). After you have made all such manual edits you can
          simply run the second action labeled "Replace tags with keys
          and insert into catalog".
</para>
<para>Note: running this action will not find translatable text within HTML or adp tags on adp pages (i.e. text in alt tags of images), nor will it find translatable text in tcl files. Such texts will have to be found manually. If those texts are in adp files they are best replaced with the &lt;#message_key text#&gt; tags that can be extracted by the action described below. Here are some commands that we used on Linux to look for texts in adp pages not found by the script:</para>
          <programlisting>
# List image tags with alt attributes, look for alt attributes with literal text
find -iname '*.adp'|xargs egrep -i '&lt;img.*alt='
# List submit buttons, look for text in the value attribute 
find -iname '*.adp'|xargs egrep -i '&lt;input[^>]*type="?submit'
</programlisting>

        <para>
          When you run this step, any modified files are backed up in
          a file with a &quot;.orig&quot; suffix. Those files are
          never overwritten, though, so the .orig file will always be
          the original page file, not the second-to-last file. Running
          this action multiple times is harmless.
        </para>

        </listitem>
  
        <listitem>
          <para>
            <emphasis role="strong">Manually verify each ADP
            file</emphasis>. If necessary, you can add additional
            &lt;#...#&gt; tags, or you can move or remove the ones set
            by the automated step.
          </para>
        </listitem>
  
        <listitem>
          <para>
            <emphasis role="strong">Manually mark up Tcl
            files</emphasis>, marking up translatable text with the
            &lt;#...#&gt; notation.
          </para>
          <para>Ttranslatable texts are often found in page titles, context bars, and form labels and options. Many times the texts are enclosed in double quotes. Use the following grep commands on Linux to highlight translatable text in tcl files for us:</para>

          <programlisting># Find text in double quotes
find -iname '*.tcl'|xargs egrep -i '"[a-z]'
# Find untranslated text in form labels, options and values
find -iname '*.tcl'|xargs egrep -i '\-(options|label|value)'|egrep -v '&lt;#'|egrep -v '\-(value|label|options)[[:space:]]+\$[a-zA-Z_]+[[:space:]]*\\?[[:space:]]*$'
# Find text in page titles and context bars
find -iname '*.tcl'|xargs egrep -i 'set (title|page_title|context_bar) '|egrep -v '&lt;#'
# Find text in error messages
find -iname '*.tcl'|xargs egrep -i '(ad_complain|ad_return_error)'|egrep -v '&lt;#'</programlisting>

          <para>You may mark up translatable text in tcl library files and tcl pages with temporary tags (on the &lt;#key text#&gt; syntax mentioned previously). If you have a sentence or paragraph of text with variables and or procedure calls in it you should in most cases try to turn the whole text into one message in the catalog. In those cases, follow these steps:</para>

          <orderedlist>
            <listitem>
              <para>              For each message call in the text, decide on a variable
              name and replace the procedure call with a variable
              lookup on the syntax %var_name%. Remember to initialize
              a tcl variable with the same name on some line above the
              text.</para>
            </listitem>
            <listitem>
              <para>If the text is in a tcl file you must replace
              variable lookups (occurences of $var_name or
              ${var_name}) with %var_name%</para>
            </listitem>
            <listitem>
              <para>You are now ready to follow the normal procedure
              and mark up the text using a tempoarary message tag (&lt;#_
              text_with_percentage_vars#&gt;) and run the action replace
              tags with keys in the APM.</para>
            </listitem>
          </orderedlist>
          <para>The variable values in the message are usually fetched with upvar, here is an example from dotlrn:</para>

          <programlisting>ad_return_complaint 1 "Error: A [parameter::get -parameter classes_pretty_name] 
             must have no[parameter::get -parameter class_instances_pretty_plural] to be deleted"
</programlisting>
<para>was replaced by:</para>

          <programlisting>set subject [parameter::get -localize -parameter classes_pretty_name] 
set class_instances [parameter::get -localize -parameter class_instances_pretty_plural]
ad_return_complaint 1 [_ dotlrn.class_may_not_be_deleted]

</programlisting>
          <para>This kind of interpolation also works in adp files where adp variable values will be inserted into the message.</para>

          <para>Alternatively, you may pass in an array list of the variable values to be interpolated into the message so that our example becomes:</para>

          <programlisting>set msg_subst_list [list subject [parameter::get -localize -parameter classes_pretty_name] 
                         class_instances [parameter::get -localize -parameter class_instances_pretty_plural]]

ad_return_complaint 1 [_ dotlrn.class_may_not_be_deleted $msg_subst_list]
</programlisting>
          <para>When we were done going through the tcl files we ran the following commands to check for mistakes:
</para>
          <programlisting># Message tags should usually not be in curly braces since then the message lookup may not be
# executed then (you can usually replace curly braces with the list command). Find message tags 
# in curly braces (should return nothing, or possibly a few lines for inspection)
find -iname '*.tcl'|xargs egrep -i '\{.*&lt;#'
# Check if you've forgotten space between default key and text in message tags (should return nothing)
find -iname '*.tcl'|xargs egrep -i '&lt;#_[^ ]'
# Review the list of tcl files with no message lookups
for tcl_file in $(find -iname '*.tcl'); do egrep -L '(&lt;#|\[_)' $tcl_file; done
</programlisting>
          <para>When you feel ready you may run the action "Replace tags with keys and insert into catalog" on the tcl files that you've edited to replace the temporary tags with calls to the message lookup procedure.</para>
          <para>The <computeroutput>acs-lang/bin/check-catalog.sh</computeroutput> script checks that the set of keys used in message lookups in tcl, adp, and info files and the set of keys in the catalog file are identical. The scripts below assume that message lookups in adp and info files are on the format #package_key.message_key#, and that message lookups in tcl files are always done with the underscore procedure. The script assumes that you have perl installed and in your path. Run the script like this:</para>

          <programlisting>acs-lang/bin/check-catalog.sh <emphasis>package_key</emphasis></programlisting>

          <para>where package_key is the key of the package that you want to test. If you don't provide the package_key argument then all packages with catalog files will be checked. The script will run its checks on en_US xml catalog files. </para>

        </listitem>
  
        <listitem>
          <para>
            <emphasis role="strong">Replace tags with keys</emphasis>:
            This is an automated process, which will replace the
            temporary &lt;#...#&gt; notation in both ADP and Tcl files
            with the appropriate notation for the type of file, and
            store the text in the message catalog. You need to run the
            process twice, once for ADP files, and once for Tcl files.
          </para>
        </listitem>
        </orderedlist>

    </sect3>
    <sect3>
      <title>Internationalize Package Parameters with visible messages</title>
      <para>
      See <xref linkend="i18n-message-catalog-params"/>
    </para>
    </sect3>

    <sect3>
      <title>Internationalize Date and Time queries</title>
      <orderedlist>
        <listitem>
          <para>Find datetime in .xql files.  Use command line tools to find suspect SQL code:</para>
          <programlisting>grep -r "to_char.*H" *
grep -r "to_date.*H" *
</programlisting>
        </listitem>
        <listitem>
          <para>In SQL statements, replace the format string with the ANSI standard format, <computeroutput>YYYY-MM-DD HH24:MI:SS</computeroutput> and change the field name to *_ansi so that it cannot be confused with previous, improperly formatting fields.  For example,</para>
          <programlisting>to_char(timestamp,'MM/DD/YYYY HH:MI:SS') as foo_date_pretty</programlisting>
          <para>becomes</para>
          <programlisting>to_char(timestamp,'YYYY-MM-DD HH24:MI:SS') as foo_date_ansi</programlisting>
        </listitem>

        <listitem>
          <para>In TCL files where the date fields are used, convert the datetime from local server timezone, which is how it's stored in the database, to the user's timezone for display.  Do this with the localizing function <computeroutput><ulink url="/api-doc/proc-view?proc=lc_time_system_to_conn">lc_time_system_to_conn</ulink></computeroutput>:</para>
<programlisting>
set foo_date_ansi [lc_time_system_to_conn $foo_date_ansi]</programlisting>
          <para>When a datetime will be written to the database, first convert it from the user's local time to the server's timezone with <computeroutput><ulink url="/api-doc/proc-view?proc=lc%5ftime%5fconn%5fto%5fsystem">lc_time_conn_to_system</ulink></computeroutput>.
</para>
        </listitem>
        <listitem>
          <para>When a datetime field will be displayed, format it using the localizing function <computeroutput><ulink url="/api-doc/proc-view?proc=lc_time_fmt">lc_time_fmt</ulink></computeroutput>. lc_time_fmt takes two parameters, datetime and format code.  Several format codes are usable for localization; they are placeholders that format dates with the appropriate codes for the user's locale.  These codes are: <computeroutput>%x, %X, %q, %Q, and %c.</computeroutput></para>
          <programlisting>set foo_date_pretty [lc_time_fmt $foo_date_ansi "%x %X"]</programlisting>
        </listitem>
      </orderedlist>
    </sect3>
  </sect2>

  <sect2 id="i18n-design">
    <title>Design Notes</title>
    <para>User locale is a property of ad_conn, <computeroutput>ad_conn locale</computeroutput>.  The request processor sets this by calling <computeroutput>lang::conn::locale</computeroutput>, which looks for the following in order of precedence:</para>
    <orderedlist>
      <listitem><para>Use user preference for this package (stored in ad_locale_user_prefs)</para></listitem>
      <listitem><para>Use system preference for the package (stored in apm_packages)</para>
      </listitem>
      <listitem><para>Use user's general preference (stored in user_preferences)</para></listitem>
      <listitem><para>Use Browser header (<computeroutput>Accept-Language</computeroutput> HTTP header)</para></listitem>
      <listitem><para>Use system locale (an APM parameter for acs_lang)</para></listitem>
<listitem><para>default to en_US</para></listitem>
    </orderedlist>
    <para>For ADP pages, message key lookup occurs in the templating engine.  For TCL pages, message key lookup happens with the <computeroutput>_</computeroutput> function.  In both cases, if the requested locale is not found but a locale which is the default for the language which matches your locale's language is
found, then that locale is offered instead.</para>
  </sect2>

</sect1>
