<?xml version='1.0' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY % myvars SYSTEM "../variables.ent">
%myvars;
]>
<chapter id="tutorial-advanced">
  <title>Advanced Topics</title>
  <authorblurb>
    <para>by <ulink url="mailto:joel@aufrecht.org">Joel Aufrecht</ulink></para>
  </authorblurb>
    <para>This tutorial covers topics which are not essential to
    creating a minimal working package.  Each section can be used
    independently of all of the others; all sections assume that
    you've completed the basic tutorial.</para>
    <sect1 id="tutorial-specs">
      <title>Write the Requirements and Design Specs</title>
      <para>It's time to document.  For the tutorial we'll use
      pre-written documentation.  When creating a package
      from scratch, start by copying the documentation template from
	<computeroutput>/var/lib/aolserver/openacs-dev/packages/acs-core-docs/xml/docs/xml/package-documentation-template.xml</computeroutput>
	to
	<computeroutput>myfirstpackage/www/docs/xml/index.xml</computeroutput>.</para>
      <para>You then edit that file with emacs to write the 
	requirements and design sections, generate the html, and start
	coding.  Store any supporting files, like page maps or schema
      diagrams, in the <computeroutput>www/doc/xml</computeroutput>
      directory, and store png or jpg versions of supporting files in the
	<computeroutput>www/doc</computeroutput> directory.</para>
      <para>For this tutorial, you should instead install the
	pre-written documentation files for the tutorial app.  Log in
      as <replaceable>service0</replaceable>, create the standard
      directories, and copy the prepared documentation:</para>
      <screen>[service0 service0]$ <userinput>cd /var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/</userinput>
[service0 myfirstpackage]$ <userinput>mkdir -p www/doc/xml</userinput>
[service0 myfirstpackage]$ <userinput>cd www/doc/xml</userinput>
[service0 xml]$ <userinput>cp /var/lib/aolserver/<replaceable>service0</replaceable>/packages/acs-core-docs/www/files/myfirstpackage/* .</userinput>
[service0 xml]$</screen>
      <para> OpenACS uses DocBook for documentation.  DocBook is
	an XML standard for semantic markup of documentation.  That
	means that the tags you use indicate meaning, not intended
	appearance.  The style sheet will determine appearance.  You
      will edit the text in an xml file, and then process the file
      into html for reading.</para>
      <para>Open the file <computeroutput>index.xml</computeroutput>
      in emacs.  Examine the file.  Find the version history (look for the tag
        <computeroutput>&lt;revhistory&gt;</computeroutput>).  Add a
        new record to the document version history.  Look for the
        <computeroutput>&lt;authorgroup&gt;</computeroutput> tag and
        add yourself as a second author.  Save and exit.  For tips on
        editing SGML files in emacs, see <xref
        linkend="docbook-primer"/></para>
      <para>Process the xml file to create html documentation.  The
      html documentation, including supporting files such as pictures,
      is stored in the <computeroutput>www/docs/</computeroutput>
      directory.  A Makefile is provided to generate html from the xml, and copy all of the
      supporting files.  If Docbook is set up correctly, all you need
      to do is:</para>
      <screen>[service0 xml]$<userinput> make</userinput>
cd .. ; /usr/bin/xsltproc ../../../acs-core-docs/www/xml/openacs.xsl xml/index.xml
Writing requirements-introduction.html for chapter(requirements-introduction)
Writing requirements-overview.html for chapter(requirements-overview)
Writing requirements-cases.html for chapter(requirements-cases)
Writing sample-data.html for chapter(sample-data)
Writing requirements.html for chapter(requirements)
Writing design-data-model.html for chapter(design-data-model)
Writing design-ui.html for chapter(design-ui)
Writing design-config.html for chapter(design-config)
Writing design-future.html for chapter(design-future)
Writing filename.html for chapter(filename)
Writing user-guide.html for chapter(user-guide)
Writing admin-guide.html for chapter(admin-guide)
Writing bi01.html for bibliography
Writing index.html for book
[service0 xml]$</screen>
      <para>Verify that the documentation was generated and reflects
      your changes by browsing to <computeroutput>http://<replaceable>yoursite</replaceable>:8000/myfirstpackage/doc</computeroutput></para>
    </sect1>
    <sect1 id="tutorial-cvs">
      <title>Add the new package to CVS</title>
      <para>Before you do any more work, make sure that your work is
      protected by putting it all into cvs.  The <computeroutput>cvs
      add</computeroutput> command is not recursive, so you'll have to
      traverse the directory tree manually and add as you go.  (<ulink
      url="http://www.piskorski.com/docs/cvs-conventions.html">More on
      CVS</ulink>)</para>
      <screen>[service0 xml]$ <userinput>cd ..</userinput>
[service0 doc]$ <userinput>cd ..</userinput>
[service0 www]$ <userinput>cd ..</userinput>
[service0 myfirstpackage]$ <userinput>cd ..</userinput>
[service0 packages]$ <userinput>cvs add myfirstpackage/</userinput>
Directory /cvsroot/<replaceable>service0</replaceable>/packages/myfirstpackage added to the repository
[service0 packages]$ <userinput>cd myfirstpackage/</userinput>
[service0 myfirstpackage]$ <userinput>cvs add www</userinput>
Directory /cvsroot/<replaceable>service0</replaceable>/packages/myfirstpackage/www added to the repository
[service0 myfirstpackage]$ <userinput>cd www</userinput>
[service0 www]$ <userinput>cvs add doc</userinput>
Directory /cvsroot/<replaceable>service0</replaceable>/packages/myfirstpackage/www/doc added to the repository
[service0 www]$ <userinput>cd doc</userinput>
[service0 doc]$ <userinput>cvs add *</userinput>
cvs add: cannot add special file `CVS'; skipping
cvs add: scheduling file `admin-guide.html' for addition
cvs add: scheduling file `bi01.html' for addition
cvs add: scheduling file `data-model.dia' for addition
cvs add: scheduling file `data-model.png' for addition
cvs add: scheduling file `design-config.html' for addition
cvs add: scheduling file `design-data-model.html' for addition
cvs add: scheduling file `design-future.html' for addition
cvs add: scheduling file `design-ui.html' for addition
cvs add: scheduling file `filename.html' for addition
cvs add: scheduling file `index.html' for addition
cvs add: scheduling file `page-map.dia' for addition
cvs add: scheduling file `page-map.png' for addition
cvs add: scheduling file `requirements-cases.html' for addition
cvs add: scheduling file `requirements-introduction.html' for addition
cvs add: scheduling file `requirements-overview.html' for addition
cvs add: scheduling file `requirements.html' for addition
cvs add: scheduling file `sample-data.html' for addition
cvs add: scheduling file `sample.png' for addition
cvs add: scheduling file `user-guide.html' for addition
cvs add: scheduling file `user-interface.dia' for addition
cvs add: scheduling file `user-interface.png' for addition
Directory /cvsroot/<replaceable>service0</replaceable>/packages/myfirstpackage/www/doc/xml added to the repository
cvs add: use 'cvs commit' to add these files permanently
[service0 doc]$ <userinput>cd xml</userinput>
[service0 xml]$ <userinput>cvs add Makefile index.xml</userinput>
cvs add: scheduling file `Makefile' for addition
cvs add: scheduling file `index.xml' for addition
cvs add: use 'cvs commit' to add these files permanently
[service0 xml]$<userinput> cd ../../..</userinput>
[service0 myfirstpackage]$ <userinput>cvs commit -m "new package"</userinput>
cvs commit: Examining .
cvs commit: Examining www
cvs commit: Examining www/doc
cvs commit: Examining www/doc/xml
RCS file: /cvsroot/<replaceable>service0</replaceable>/packages/myfirstpackage/www/doc/admin-guide.html,v
done
Checking in www/doc/admin-guide.html;
/cvsroot/<replaceable>service0</replaceable>/packages/myfirstpackage/www/doc/admin-guide.html,v  &lt;--  admin-guide.html
initial revision: 1.1
done
<emphasis>(many lines omitted)</emphasis>
[service0 myfirstpackage]$</screen>
        <figure>
          <title>Upgrading a local CVS repository</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/development-with-cvs.png" format="png" align="center"/>
            </imageobject>
          </mediaobject>
        </figure>
    </sect1>
   <sect1 id="tutorial-comments">
     <title>Adding Comments</title>
     <para>You can track comments for any ACS Object.  Here we'll track
     comments for notes.  On the note-edit.tcl/adp pair, which is used to
     display individual notes, we want to put a link to add comments at
     the bottom of the screen.  If there are any comments, we want to
     show them.</para>
     <para>First, we need to generate a url for adding comments.  In note-edit.tcl:</para>
     <programlisting>
 set comment_add_url "[general_comments_package_url]comment-add?[export_vars {
  { object_id $note_id } 
  { object_name $title } 
  { return_url "[ad_conn url]?[ad_conn query]"} 
 }]"
 </programlisting>
     <para>This calls a global, public tcl function that the
     general_comments package registered, to get its url. You then
     embed in that url the id of the note and its title, and set the
     return_url to the current url so that the user can return after
     adding a comment.</para>
     <para>We need to create html that shows any existing comments.
     We do this with another general_comments function:</para>
     <programlisting>set comments_html [general_comments_get_comments
     -print_content_p 1 $note_id]</programlisting>
     <para>First, we pass in an optional parameter that that says to actually
     show the contents of the comments, instead of just the fact that
     there are comments. Then you pass the note id, which is also the
     acs_object id.</para>
     <para>We put our two new variables in the note-edit.adp
     page.</para>
     <programlisting>&lt;a href="@comment_add_url@"&gt;Add a comment&lt;/a&gt;
 @comments_html@</programlisting>
   </sect1>
   <sect1 id="tutorial-admin-pages">
     <title>Admin Pages</title>
     <para>
     There are at least two flavors of admin user interface:
     </para>
     <itemizedlist>
       <listitem><para>Admins use same pages as all other users, except
       that they are offered admin links and buttons where appropriate.
       For example, if admins have privilege to bulk-delete items you
       could provide checkboxes next to every item seen on a list and the
       Delete Selected button on the bottom of the list.
       </para></listitem>
       <listitem><para>Dedicated admin pages.  If you want admins to have
       access to data that users aren't interested in or aren't allowed
       to see you will need dedicated admin pages.  The conventional
       place to put those dedicated admin pages is in the
 <computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin</computeroutput>
 directory.
      </para>
<screen>[service0 www]$ <userinput>mkdir admin</userinput></screen>
<screen>[service0 www]$ <userinput>cd admin</userinput></screen>
      <para>
      Even if your application doesn't need any admin pages of its own you will
      usually need at least one simple page with a bunch of links to existing
      administration UI such as Category Management or standard Parameters UI.
      Adding the link to Category Management is described in the section on
      categories.  The listing below adds a link to the Parameters UI of our
      package.
      </para>
<screen>[service0 admin]$ <userinput>vi index.adp</userinput></screen>
<programlisting>
&lt;master&gt;
&lt;property name="title"&gt;@title;noquote@&lt;/property&gt;
&lt;property name="context"&gt;@context;noquote@&lt;/property&gt;

&lt;ul class="action-links"&gt;
  &lt;li&gt;&lt;a href="@parameters_url@" title="Set parameters" class="action_link"&gt;Set parameters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</programlisting>
<screen>[service0 admin]$ <userinput>vi index.tcl</userinput></screen>
<programlisting>
ad_page_contract {} {
} -properties {
    context_bar
}

set package_id [ad_conn package_id]

permission::require_permission \
          -object_id $package_id \
          -privilege admin]

set context [list]

set title "Administration"

set parameters_url [export_vars -base "/shared/parameters" {
  package_id { return_url [ad_return_url] }
}]

</programlisting>

<para>
Now that you have the first admin page it would be nice to have a link to it
somewhere in the system so that admins don't have to type in the
<computeroutput>/admin</computeroutput> every time they need to reach it.  You
could put a static link to the toplevel
<computeroutput>index.adp</computeroutput> but that might be distracting for
people who are not admins.  Besides, some people consider it impolite to first
offer a link and then display a nasty "You don't have permission to access this
page" message.
</para>
<para>
In order to display the link to the admin page only to users that have admin
privileges add the following code near the top of
<computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin/index.tcl</computeroutput>:
</para>
<programlisting>

set package_id [ad_conn package_id]

set admin_p [permission::permission_p -object_id $package_id \
  -privilege admin -party_id [ad_conn untrusted_user_id]]

if { $admin_p } {
    set admin_url "admin"
    set admin_title Administration
}
</programlisting>
<para>
In 
<computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin/index.adp</computeroutput> put:
</para>
<programlisting>
&lt;if @admin_p@ ne nil&gt;
  &lt;a href="@admin_url@"&gt;@admin_title@&lt;/a&gt;
&lt;/if&gt;
</programlisting>

      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="tutorial-categories">
    <title>Categories</title>

    <para>You can associate any ACS Object with one or more categories.
    In this tutorial we'll show how to equip your application with user
    interface to take advantage of the Categories service.
    </para>
    <para>
    We'll start by installing the Categories service.  Go to
    <computeroutput>/acs/admin</computeroutput> and install it.  This step
    won't be necessary for the users of your applications because you'll create
    a dependency with the Package Manager which will take care that the
    Categories service always gets installed when your application gets
    installed.
    </para>
    <para>
    Now that we have installed the Categories service we can proceed to
    modifying our application so that it can take advantage of it.  We'll do it
    in three steps:
    </para>
    <orderedlist>
        <listitem><para>
          The Categories service provides a mechanism to associate one or
          more <emphasis>category trees</emphasis> that are relevant to
          your application.  One example of such tree is a tree of
          geographical locations.  Continents are on the top of such tree,
          each continent containing countries etc.  Another tree might
          contain market segments etc.  Before users of your application
          can take advantage of the Categories service there needs to be a
          way for administrators of your application to choose which
          category trees are applicable for the application.
          </para>
          <para>
          The way to achieve this is is to provide a link
          to the Category Management pages.  Add the following snippet to your
            <computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin/index.tcl</computeroutput>
          file:
          </para>
          <programlisting>
set category_map_url [export_vars -base \
    "[site_node::get_package_url -package_key categories]cadmin/one-object" \
        { { object_id $package_id } }]
          </programlisting>
          <para>
          and the following snippet to your
            <computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin/index.adp</computeroutput>
          file:
          </para>
          <programlisting>
&lt;li&gt;&lt;a href="@category_map_url@"
      class="action_link"&gt;Site-Wide Categories&lt;/a&gt;
          </programlisting>
          <para>The link created by the above code will take the admin to the generic
          admin UI where he can pick category trees that make sense for this
          application.  The same UI also includes facilities to build and edit
          category trees.  Notice that the only parameter in this example is
          <computeroutput>package_id</computeroutput> so that category trees
          will be associated with the object identified by this
          <computeroutput>package_id</computeroutput>.  The categorization
          service is actually more general than that: instead of
          <computeroutput>package_id</computeroutput> you could use an ID of
          some other object that serves as a "container" in your application.
          For example, if your discussion forums application supports multiple
          forums you would use <computeroutput>forum_id</computeroutput> to
          associate category trees with just that one forum rather than the
          entire application instance.
        </para></listitem>
      <listitem><para>
          Once the category trees have been selected users need a way
          to categorize items.  The easiest way to do this is by adding the
          <computeroutput>category</computeroutput> widget type of the
          form builder to <computeroutput>note-edit.tcl</computeroutput>.
          To achieve this we'll need to use the <computeroutput>-extend</computeroutput>
          switch to the <computeroutput>ad_form</computeroutput> command. Here's the "meat" of the
          <computeroutput>note-edit.tcl</computeroutput> page:</para>
          <programlisting>
ad_form -name note -form {
    {item_id:key}
    {title:text {label Title}}
}

set package_id [ad_conn package_id]

set category_trees [category_tree::get_mapped_trees $package_id]

foreach tree $category_trees {
    foreach { tree_id name subtree_id } $tree {}
    ad_form -extend -name note -form \
        [list [list category_id_${tree_id}:integer(category),optional \
                   {label $name} \
                   {html {single single}} \
                   {category_tree_id $tree_id} \
                   {category_subtree_id $subtree_id} \
                   {category_object_id {[value_if_exists entry_id]}}]]
}

ad_form -extend \
  -name note \
  -new_request {
    permission::require_permission -object_id [ad_conn package_id] -privilege create
    set page_title "Add a Note"
    set context [list $page_title]
} -edit_request {
    permission::require_write_permission -object_id $item_id
    mfp::note::get \
    -item_id $item_id \
    -array note_array

    set title $note_array(title)

    set page_title "Edit a Note"
    set context [list $page_title]
} -new_data {
    mfp::note::add \
    -title $title
} -after_submit {
    ad_returnredirect "."
    ad_script_abort
}</programlisting>
    <para>This page requires a
<computeroutput>note_id</computeroutput> to determine which record
should be deleted.  It also looks for a confirmation variable, which
should initially be absert.  If it is absent, we create a form to
allow the user to confirm the deletion.  Note that in
<computeroutput>entry-edit.tcl</computeroutput> we used <computeroutput>ad_form</computeroutput> to access the Form Template
commands; here, we call them directly because we don't need the extra
features of ad_form.  The form calls itself, but
with hidden variables carrying both
<computeroutput>note_id</computeroutput> and
<computeroutput>confirm_p</computeroutput>.  If confirm_p is present,
we delete the record, set redirection back to the index, and abort
script execution.</para>

      <para>The database commands:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-delete.xql</userinput></screen>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="do_delete"&gt;
    &lt;querytext&gt;
      select samplenote__delete(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="get_name"&gt;
    &lt;querytext&gt;
      select samplenote__name(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>And the adp page:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-delete.adp</userinput></screen>
      <programlisting>&lt;master&gt;
&lt;property name="title"&gt;@title@&lt;/property&gt;
&lt;property name="context"&gt;{@title@}&lt;/property&gt;
&lt;h2&gt;@title@&lt;/h2&gt;
&lt;formtemplate id="note-del-confirm"&gt;&lt;/formtemplate&gt;
&lt;/form&gt;</programlisting>
    <para>The ADP is very simple.  The
<computeroutput>formtemplate</computeroutput> tag outputs the HTML
form generated by the ad_form command with the matching name.  Test it
      by adding the new files in the APM and then deleting a few
      samplenotes.</para>
      </listitem>
    </orderedlist>
  </sect1>
  <sect1>
    <title>Categories</title>

    <para>You can associate any ACS Object with one or more categories.
    In this tutorial we'll show how to equip your application with user
    interface to take advantage of the Categories service.
    </para>
    <para>
    We'll start by installing the Categories service.  Go to
    <computeroutput>/acs/admin</computeroutput> and install it.  This step
    won't be necessary for the users of your applications because you'll create
    a dependency with the Package Manager which will take care that the
    Categories service always gets installed when your application gets
    installed.
    </para>
    <para>
    Now that we have installed the Categories service we can proceed to
    modifying our application so that it can take advantage of it.  We'll do it
    in three steps:
    </para>
    <orderedlist>
        <listitem><para>
          The Categories service provides a mechanism to associate one or
          more <emphasis>category trees</emphasis> that are relevant to
          a particular application instance.  One example of such tree is a tree of
          geographical locations.  Continents are on the top of such tree,
          each continent containing countries etc.  Another tree might
          contain market segments etc.  Before users of your application
          can take advantage of the Categories service there needs to be a
          way for administrators of your application to choose which
          category trees are applicable for the application.</para>
          <para>
          The way to achieve this is is to provide a link
          to the Category Management pages.  Add the following snippet to your
            <computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin/index.tcl</computeroutput>
          file:
          </para>
          <programlisting>
set category_map_url [export_vars -base \
    "[site_node::get_package_url -package_key categories]cadmin/one-object" \
        { { object_id $package_id } }]
          </programlisting>
          <para>
          and the following snippet to your
            <computeroutput>/var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www/admin/index.adp</computeroutput>
          file:
          </para>
          <programlisting>
&lt;li&gt;&lt;a href="@category_map_url@"
      class="action_link"&gt;Site-Wide Categories&lt;/a&gt;
          </programlisting>
          <para>The link created by the above code will take the admin to the generic
          admin UI where he can pick category trees that make sense for this
          application.  The same UI also includes facilities to build and edit
          category trees.  Notice that the only parameter in this example is
          <computeroutput>package_id</computeroutput> so that category trees
          will be associated with the object identified by this
          <computeroutput>package_id</computeroutput>.  The categorization
          service is actually more general than that: instead of
          <computeroutput>package_id</computeroutput> you could use an ID of
          some other object that serves as a "container" in your application.
          For example, if your discussion forums application supports multiple
          forums you would use <computeroutput>forum_id</computeroutput> to
          associate category trees with just that one forum rather than the
          entire application instance.
        </para></listitem>
      <listitem><para>
          Once the category trees have been selected users need a way
          to categorize items.  The easiest way to do this is by adding the
          <computeroutput>category</computeroutput> widget type of the
          form builder to <computeroutput>note-edit.tcl</computeroutput>.
          To achieve this we'll need to use the <computeroutput>-extend</computeroutput>
          switch to the <computeroutput>ad_form</computeroutput> command. Here's the
          <computeroutput>note-edit.tcl</computeroutput> page with added sections
          emphasized.
<programlisting>ad_page_contract {
    This is the view-edit page for notes.

    @author Your Name (you@example.com)
    @cvs-id &#x0024;Id$

    @param item_id If present, assume we are editing that note.  Otherwise, we
    are creating a new note.

} { 
    item_id:integer,optional
}

ad_form -name note -form {
    {item_id:key}
    {title:text {label Title}}
<userinput>}

category::ad_form::add_widgets \
  -form_name note \
  -container_object_id [ad_conn package_id] \
  -categorized_object_id [value_if_exists item_id]

ad_form -extend -name note \ </userinput>
  -new_request {
    permission::require_permission -object_id [ad_conn package_id] -privilege create
    set page_title "Add a Note"
    set context [list $page_title]
} -edit_request {
    permission::require_write_permission -object_id $item_id
    mfp::note::get \
    -item_id $item_id \
    -array note_array

    set title $note_array(title)

    set page_title "Edit a Note"
    set context [list $page_title]
<userinput>} -on_submit {
    set category_ids [category::ad_form::get_categories \
      -container_object_id [ad_conn package_id]]</userinput>
} -new_data {
    mfp::note::add \
    -title $title \
    -item_id $item_id
<userinput>
    category::map_object \
      -remove_old \
      -object_id $item_id \
       $category_ids
</userinput>
    set message "Note $title added"
} -edit_data {
    mfp::note::edit \
    -item_id $item_id \
    -title $title
<userinput>
    category::map_object \
      -remove_old \
      -object_id $item_id \
       $category_ids
</userinput>

     set message "Note $title changed"
} -after_submit {
    ad_returnredirect -message $message "."
    ad_script_abort
}</programlisting>
<para>
  Note how we have replaced what was a single
  <computeroutput>ad_form</computeroutput> invocation with two.  The
  <computeroutput>-extend</computeroutput> flag is used to build a form
  incrementally.  We had to do it so that we can insert the call to
  <computeroutput>category::ad_form::add_widgets</computeroutput>.  This
  procedure will add as many category widgets as there are trees associated with
  our <computeroutput>package_id</computeroutput>.  The complementary proc
  <computeroutput>category::ad_form::get_categories</computeroutput> will take
  care of collecting the values after the form has been submitted.  The block
  <computeroutput>-on_submit</computeroutput> will get executed at this time,
  followed by execution of either <computeroutput>-new_data</computeroutput> or
  <computeroutput>-edit_data</computeroutput>, depending on whether we are adding
  a new note or editing an existing one.
</para>
      </para></listitem>
    </orderedlist>
    </sect1>

      <sect1 id="tutorial-distribute">
        <title>Prepare the package for distribution.</title>
        <para>Browse to the package manager.  Click on
        <computeroutput><guilabel>tutorialapp</guilabel></computeroutput>.</para>
        <para>Click on <computeroutput><guilabel>Generate a distribution file
        for this package from the
        filesystem</guilabel></computeroutput>.
        </para>
        <para>Click on the file size
        (<computeroutput><guilabel>37.1KB</guilabel></computeroutput>)
        after the label <computeroutput><guilabel>Distribution
        File:</guilabel></computeroutput> and save the file to
        /tmp.</para>
        <para><indexterm>
            <primary>The publish point for new packages should be
        fixed.</primary>
          </indexterm>
</para>
      </sect1>

  <sect1 id="tutorial-notifications">
    <title>Notifications</title>
    <authorblurb>
      <para>by <ulink url="mailto:dave@student.usyd.edu.au">David Bell</ulink> and <ulink url="mailto:simon@collaboraid.net">Simon Carstensen</ulink></para>
    </authorblurb>

    <para>The notifications package allows you to send notifications through any 
    defined communications medium (e.g. email, sms) upon some event occuring within 
    the system.</para>
    <para>This tutorial steps through the process of integrating the notifications 
    package with your package.</para>
   
    <para>First step is to create the notification types. To do this a script similar 
    to the one below needs to be loaded into Postgresql. I create this script in a 
    package-name/sql/postgresql/package-name-notifications-init.sql file. I then load 
    this file from my create sql file. The following code snippet is taken from 
    Weblogger. It creates a lars_blogger_notif notification type (which was created 
    above).</para>

    <programlisting>
    create function inline_0() returns integer as '
    declare
            impl_id integer;
            v_foo   integer;
    begin
        -- the notification type impl
        impl_id := acs_sc_impl__new (
                      ''NotificationType'',
                      ''lars_blogger_notif_type'',
                      ''lars-blogger''
        );

        v_foo := acs_sc_impl_alias__new (
                    ''NotificationType'',
                    ''lars_blogger_notif_type'',
                    ''GetURL'',
                    ''lars_blogger::notification::get_url'',
                    ''TCL''
        );

        v_foo := acs_sc_impl_alias__new (
                    ''NotificationType'',
                    ''lars_blogger_notif_type'',
                    ''ProcessReply'',
                    ''lars_blogger::notification::process_reply'',
                    ''TCL''
        );

        PERFORM acs_sc_binding__new (
                    ''NotificationType'',
                    ''lars_blogger_notif_type''
        );

        v_foo:= notification_type__new (
	        NULL,
                impl_id,
                ''lars_blogger_notif'',
                ''Blog Notification'',
                ''Notifications for Blog'',
		now(),
                NULL,
                NULL,
		NULL
        );

        -- enable the various intervals and delivery methods
        insert into notification_types_intervals
        (type_id, interval_id)
        select v_foo, interval_id
        from notification_intervals where name in (''instant'',''hourly'',''daily'');

        insert into notification_types_del_methods
        (type_id, delivery_method_id)
        select v_foo, delivery_method_id
        from notification_delivery_methods where short_name in (''email'');

        return (0);
    end;
    ' language 'plpgsql';

    select inline_0();
    drop function inline_0();
    </programlisting>

    <para>You also need a drop script. This is untested for
    comptability with the above script.</para>
    <programlisting>
--
-- Project Manager
--
-- @author jader@bread.com
-- @author gwong@orchardlabs.com,ben@openforce.biz
-- @creation-date 2002-05-16
--
-- This code is newly concocted by Ben, but with significant concepts and code
-- lifted from Gilbert's UBB forums. Thanks Orchard Labs.
-- Jade in turn lifted this from gwong and ben.
--

create function inline_0 ()
returns integer as '
declare
    row                             record;
begin
    for row in select nt.type_id
               from notification_types nt
               where nt.short_name in (''lars_blogger_notif'')
    loop
        perform notification_type__delete(row.type_id);
    end loop;

    return null;
end;' language 'plpgsql';

select inline_0();
drop function inline_0 ();

--
-- Service contract drop stuff was missing - Roberto Mello 
--

create function inline_0() returns integer as '
declare
        impl_id integer;
        v_foo   integer;
begin

        -- the notification type impl
        impl_id := acs_sc_impl__get_id (
                      ''NotificationType'',             -- impl_contract_name
                      ''lars_blogger_notif_type'' -- impl_name
        );

        PERFORM acs_sc_binding__delete (
                    ''NotificationType'',
                    ''lars_blogger_notif_type''
        );

        v_foo := acs_sc_impl_alias__delete (
                    ''NotificationType'',               -- impl_contract_name   
                    ''lars_blogger_notif_type'',        -- impl_name
                    ''GetURL''                          -- impl_operation_name
        );

        v_foo := acs_sc_impl_alias__delete (
                    ''NotificationType'',               -- impl_contract_name   
                    ''lars_blogger_notif_type'',        -- impl_name
                    ''ProcessReply''                    -- impl_operation_name
        );

        select into v_foo type_id 
          from notification_types
         where sc_impl_id = impl_id
          and short_name = ''lars_blogger_notif'';

        perform notification_type__delete (v_foo);

        delete from notification_types_intervals
         where type_id = v_foo 
           and interval_id in ( 
                select interval_id
                  from notification_intervals 
                 where name in (''instant'',''hourly'',''daily'')
        );

        delete from notification_types_del_methods
         where type_id = v_foo
           and delivery_method_id in (
                select delivery_method_id
                  from notification_delivery_methods 
                 where short_name in (''email'')
        );

        return (0);
end;
' language 'plpgsql';

select inline_0();
drop function inline_0();

    </programlisting>

    <para>The next step is to setup our notification creation. A new notification must 
    be added to the notification table for each blog entry added. We do this using the 
    notification::new procedure</para>

    <programlisting>
        notification::new \
            -type_id [notification::type::get_type_id \
            -short_name lars_blogger_notif] \
            -object_id $blog(package_id) \
            -response_id $blog(entry_id) \
            -notif_subject $blog(title) \
            -notif_text $new_content
    </programlisting>

    <para>This code is placed in the tcl procedure that creates blog entries, right after
    the entry gets created in the code. The <computeroutput>$blog(package_id)</computeroutput> 
    is the OpenACS object_id of the Weblogger instance to which the entry has been posted to 
    and the <computeroutput>$new_content</computeroutput> is the content of the entry.</para>

    <para>The final step is to setup the notification subscription process. In this 
    example we want to let a user find out when a new entry has been posted to the blog. To 
    do this we put a link on the blog that allows them to subscribe to notifications of new 
    entries. The notifications/requests-new page is very handy in this situation.</para>

    <para>Such a link can be created using the <computeroutput>notification::display::request_widget</computeroutput> 
    proc:</para>
    <programlisting>
    set notification_chunk [notification::display::request_widget \
        -type lars_blogger_notif \
        -object_id $package_id \
        -pretty_name [lars_blog_name] \
        -url [lars_blog_public_package_url] \
    ]
    </programlisting>

    <para>which will return something like

    <programlisting>
    You may &lt;a href="/notifications/request-new?..."&gt;request notification&lt;/a&gt; for Weblogger.</programlisting>

    which can be readily put on the blog index page. The <computeroutput>pretty_name</computeroutput> 
    parameter is what appears at the end of the text returned (i.e. "... request notification&lt;/a&gt; for pretty_name"), 
    The <computeroutput>url</computeroutput> parameter should be set to the address we want the user 
    to be redirected to after they have finished the subscription process.</para>

    <para>This should be all you need to implement a notification system. For more examples
    look at the forums package.</para>
  </sect1>

  <sect1 id="tutorial-vuh">
    <title>Using .vuh files for pretty urls</title>
    <para>.Vuh files are special cases of .tcl files, used for rewriting incoming urls.  We can use a vuh file to prettify the uri for our notes.  Instead of <computeroutput>note-edit?item_id=495</computeroutput>, we can use <computeroutput>note/495</computeroutput>.  To do this, we will need a new .vuh file for redirection and we will need to change the referring links in note-list.  First, add the vuh:</para>
      <screen>[service0 service0]$ <userinput>cd /var/lib/aolserver/<replaceable>service0</replaceable>/packages/myfirstpackage/www</userinput>
[service0 www]$ <userinput>emacs note.vuh</userinput>
</screen>
    <para>Paste this into the file:</para>
    <programlisting><xi:include href="../../files/tutorial/note.vuh" xi:parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"><xi:fallback>example missing</xi:fallback></xi:include></programlisting>
    <para>We parse the incoming request and treat everything after the final / as the item id.  Note that this simple redirection will lose any additional query parameters passed in.  Many OpenACS objects maintain a pretty-name, which is a unique, human-readable string, usually derived from title, which makes an even better 'pretty url' than a numeric id; this requires that your display page be able to look up an item based on pretty id.</para>
    <para>We use <computeroutput>rp_form_put</computeroutput> to store the item id in the internal register that the next page is expecting, and then redirects the request in process internally (ie, without a browser refresh).</para>
    <para>Next, modify note-list so that its link is of the new form.:</para>
      <screen>[service0 www]$ <userinput>emacs ../lib/note-edit.tcl</userinput></screen>
    <programlisting>
db_multirow \
    -extend {
	edit_url
	delete_url
    } notes notes_select {
	select ci.item_id,
	       n.title
        from   cr_items ci,
               mfp_notesx n
        where  n.revision_id = ci.live_revision
    } {
	<emphasis role="strong">set edit_url [export_vars -base "note/$item_id"]</emphasis>
	set delete_url [export_vars -base "note-delete" {item_id}]
    }
</programlisting>

  </sect1>
  <sect1 id="tutorial-future-topics">
  <para>Future Topics:</para>
    <itemizedlist>
      <listitem><para>How to enforce security so that users can't
      change other users records</para>
      </listitem>
      <listitem><para>How to use the content management tables so that
      ... what?</para></listitem>
      <listitem><para>How to change the default stylesheets for Form
      Builder HTML forms.</para></listitem>
      <listitem><para>How to make your package searchable with OpenFTS/Oracle</para></listitem>
      <listitem><para>How to prepare pagelets for inclusion in other pages</para></listitem>
      <listitem><para>How and when to put procedures in a tcl procedure library</para></listitem>
      <listitem><para>More on ad_form - data validation, other stuff.
      (plan to draw from Jon Griffin's doc)</para></listitem>
      <listitem><para>How and when to implement caching</para></listitem>
      <listitem><para>partialquery in xql</para></listitem>
      <listitem><para>How to use the html/text entry widget to get the
      "does this look right" confirm page </para></listitem>
      <listitem><para>APM package dependencies</para></listitem>
    </itemizedlist>
  <para>See also the <ulink url="http://openacs.org/faq/one-faq?faq_id=43841">OpenACS Programming FAQ</ulink></para>
  </sect1>
</chapter>
