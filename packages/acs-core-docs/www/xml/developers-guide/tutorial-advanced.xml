<?xml version='1.0' ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY % myvars SYSTEM "../variables.ent">
%myvars;
]>
<sect1 id="tutorial-advanced">
  <title>Advanced Topics</title>
  <important>
    <para>This section is a work in progress.</para>
  </important>
  <authorblurb>
    <para>by <ulink url="mailto:joel@aufrecht.org">Joel Aufrecht</ulink></para>
  </authorblurb>
  
  <sect2>
    <title>Overview</title>
    <para>This tutorial covers topics which are not essential to
    creating a minimal working package.  Each section can be used
    independently of all of the others; all sections assume that
    you've completed the basic tutorial.</para>

    <itemizedlist>
      <listitem><para>How to enforce security so that users can't
      change other users records</para>
      </listitem>
      <listitem><para>How to use the content management tables so that
      ... what?</para></listitem>
      <listitem><para>How to change the default stylesheets for Form
      Builder HTML forms.</para></listitem>
      <listitem><para>How to make your package searchable with OpenFTS/Oracle</para></listitem>
      <listitem><para>How to make your package send email notifications</para></listitem>
      <listitem><para>How to prepare pagelets for inclusion in other pages</para></listitem>
      <listitem><para>How and when to put procedures in a tcl procedure library</para></listitem>
      <listitem><para>How to add general_comments to your pages</para></listitem>
      <listitem><para>More on ad_form - data validation, other stuff.
      (plan to draw from Jon Griffin's doc)</para></listitem>
      <listitem><para>How and when to implement caching</para></listitem>
      <listitem><para>partialquery in xql</para></listitem>
      <listitem><para>How to use the html/text entry widget to get the
      "does this look right" confirm page </para></listitem>
      <listitem><para>APM package dependencies</para></listitem>
    </itemizedlist>

  </sect2>
    <sect2>
      <title>Write the Requirements and Design Specs</title>
      <para>It's time to document.  For the tutorial we'll use
      pre-written documentation.  When creating a package
      from scratch, start by copying the documentation template from
	<computeroutput>/var/lib/aolserver/openacs-dev/packages/acs-core-docs/xml/docs/xml/package-documentation-template.xml</computeroutput>
	to
	<computeroutput>yourpackage/www/docs/xml/index.xml</computeroutput>.</para>
      <para>You then edit that file with emacs to write the 
	requirements and design sections, generate the html, and start
	coding.  Store any supporting files, like page maps or schema
      diagrams, in the <computeroutput>www/doc/xml</computeroutput>
      directory, and store png or jpg versions of supporting files in the
	<computeroutput>www/doc</computeroutput> directory.</para>
      <para>For this tutorial, you should instead install the
	pre-written documentation files for the tutorial app.  Log in
      as <replaceable>service0</replaceable>, create the standard
      directories, and copy the prepared documentation:</para>
      <screen>[service0 service0]$ <userinput>cd /var/lib/aolserver/service0/packages/samplenote/</userinput>
[service0 samplenote]$ <userinput>mkdir -p www/doc/xml</userinput>
[service0 samplenote]$ <userinput>cd www/doc/xml</userinput>
[service0 xml]$ <userinput>cp /var/lib/aolserver/service0/packages/acs-core-docs/www/files/samplenote/* .</userinput>
[service0 xml]$</screen>
      <para> OpenACS uses DocBook for documentation.  DocBook is
	an XML standard for semantic markup of documentation.  That
	means that the tags you use indicate meaning, not intended
	appearance.  The style sheet will determine appearance.  You
      will edit the text in an xml file, and then process the file
      into html for reading.</para>
      <para>Open the file <computeroutput>index.xml</computeroutput>
      in emacs.  Examine the file.  Find the version history (look for the tag
        <computeroutput>&lt;revhistory&gt;</computeroutput>).  Add a
        new record to the document version history.  Look for the
        <computeroutput>&lt;authorgroup&gt;</computeroutput> tag and
        add yourself as a second author.  Save and exit.  For tips on
        editing SGML files in emacs, see <xref
        linkend="docbook-primer"/></para>
      <para>Process the xml file to create html documentation.  The
      html documentation, including supporting files such as pictures,
      is stored in the <computeroutput>www/docs/</computeroutput>
      directory.  A Makefile is provided to generate html from the xml, and copy all of the
      supporting files.  If Docbook is set up correctly, all you need
      to do is:</para>
      <screen>[service0 xml]$<userinput> make</userinput>
cd .. ; /usr/bin/xsltproc ../../../acs-core-docs/www/xml/openacs.xsl xml/index.xml
Writing requirements-introduction.html for sect1(requirements-introduction)
Writing requirements-overview.html for sect1(requirements-overview)
Writing requirements-cases.html for sect1(requirements-cases)
Writing sample-data.html for sect1(sample-data)
Writing requirements.html for chapter(requirements)
Writing design-data-model.html for sect1(design-data-model)
Writing design-ui.html for sect1(design-ui)
Writing design-config.html for sect1(design-config)
Writing design-future.html for sect1(design-future)
Writing filename.html for chapter(filename)
Writing user-guide.html for chapter(user-guide)
Writing admin-guide.html for chapter(admin-guide)
Writing bi01.html for bibliography
Writing index.html for book
[service0 xml]$</screen>
      <para>Verify that the documentation was generated and reflects
      your changes by browsing to <computeroutput>http://<replaceable>yoursite</replaceable>:8000/samplenote/doc</computeroutput></para>
    </sect2>
    <sect2>
      <title>Add the new package to CVS</title>
      <para>Before you do any more work, make sure that your work is
      protected by putting it all into cvs.  The <computeroutput>cvs
      add</computeroutput> command is not recursive, so you'll have to
      traverse the directory tree manually and add as you go.  (<ulink
      url="http://www.piskorski.com/docs/cvs-conventions.html">More on
      CVS</ulink>)</para>
      <screen>[service0 xml]$ <userinput>cd ..</userinput>
[service0 doc]$ <userinput>cd ..</userinput>
[service0 www]$ <userinput>cd ..</userinput>
[service0 samplenote]$ <userinput>cd ..</userinput>
[service0 packages]$ <userinput>cvs add samplenote/</userinput>
Directory /cvsroot/service0/packages/samplenote added to the repository
[service0 packages]$ <userinput>cd samplenote/</userinput>
[service0 samplenote]$ <userinput>cvs add www</userinput>
Directory /cvsroot/service0/packages/samplenote/www added to the repository
[service0 samplenote]$ <userinput>cd www</userinput>
[service0 www]$ <userinput>cvs add doc</userinput>
Directory /cvsroot/service0/packages/samplenote/www/doc added to the repository
[service0 www]$ <userinput>cd doc</userinput>
[service0 doc]$ <userinput>cvs add *</userinput>
cvs add: cannot add special file `CVS'; skipping
cvs add: scheduling file `admin-guide.html' for addition
cvs add: scheduling file `bi01.html' for addition
cvs add: scheduling file `data-model.dia' for addition
cvs add: scheduling file `data-model.png' for addition
cvs add: scheduling file `design-config.html' for addition
cvs add: scheduling file `design-data-model.html' for addition
cvs add: scheduling file `design-future.html' for addition
cvs add: scheduling file `design-ui.html' for addition
cvs add: scheduling file `filename.html' for addition
cvs add: scheduling file `index.html' for addition
cvs add: scheduling file `page-map.dia' for addition
cvs add: scheduling file `page-map.png' for addition
cvs add: scheduling file `requirements-cases.html' for addition
cvs add: scheduling file `requirements-introduction.html' for addition
cvs add: scheduling file `requirements-overview.html' for addition
cvs add: scheduling file `requirements.html' for addition
cvs add: scheduling file `sample-data.html' for addition
cvs add: scheduling file `sample.png' for addition
cvs add: scheduling file `user-guide.html' for addition
cvs add: scheduling file `user-interface.dia' for addition
cvs add: scheduling file `user-interface.png' for addition
Directory /cvsroot/service0/packages/samplenote/www/doc/xml added to the repository
cvs add: use 'cvs commit' to add these files permanently
[service0 doc]$ <userinput>cd xml</userinput>
[service0 xml]$ <userinput>cvs add Makefile index.xml</userinput>
cvs add: scheduling file `Makefile' for addition
cvs add: scheduling file `index.xml' for addition
cvs add: use 'cvs commit' to add these files permanently
[service0 xml]$<userinput> cd ../../..</userinput>
[service0 samplenote]$ <userinput>cvs commit -m "new package"</userinput>
cvs commit: Examining .
cvs commit: Examining www
cvs commit: Examining www/doc
cvs commit: Examining www/doc/xml
RCS file: /cvsroot/service0/packages/samplenote/www/doc/admin-guide.html,v
done
Checking in www/doc/admin-guide.html;
/cvsroot/service0/packages/samplenote/www/doc/admin-guide.html,v  &lt;--  admin-guide.html
initial revision: 1.1
done
<emphasis>(many lines omitted)</emphasis>
[service0 samplenote]$</screen>
    </sect2>
  <sect2>
    <title>Delete with confirmation</title>
    <para>We need a way to delete records.  We'll create a
    recursive confirmation page.</para>
    <para>Add this column to the table_def in index.tcl</para>
    <programlisting>{delete "" {} {&lt;td&gt;&lt;a href="note-delete?note_id=$note_id"&gt;Delete&lt;/a&gt;&lt;/td&gt;}}</programlisting>
    <para>Create the delete confirmation/execution page.</para>
    <screen>[service0 www]$ <userinput>emacs note-delete.tcl</userinput></screen>
      <programlisting>ad_page_contract {
    A page that gets confirmation and then delete notes.

    @author joel@aufrecht.org
    @creation-date 2003-02-12
    @cvs-id $Id$
} {
    note_id:integer
    confirm_p:optional
}

set title "Delete Note"

if {![exists_and_not_null confirm_p]} {
    # first pass, not confirmed.  Display a form for confirmation
    set note_name [db_string get_name { *SQL }]
    set title "Delete $note_name"
    template::form::create note-del-confirm
    template::element::create note-del-confirm note_id -value $note_id -widget hidden
    template::element::create note-del-confirm confirm_p -value 1 -widget hidden
    template::element::create note-del-confirm submit \
      -label "Confirm deletion of $note_name" \
      -widget submit
} else {
    # second pass, confirmed.  Call the database to delete the record
    db_1row do_delete { *SQL* }
    ad_returnredirect "index"
    ad_script_abort
}</programlisting>
    <para>This page requires a
<computeroutput>note_id</computeroutput> to determine which record
should be deleted.  It also looks for a confirmation variable, which
should initially be absert.  If it is absent, we create a form to
allow the user to confirm the deletion.  Note that in
<computeroutput>entry-edit.tcl</computeroutput> we used <computeroutput>ad_form</computeroutput> to access the Form Template
commands; here, we call them directly because we don't need the extra
features of ad_form.  The form calls itself, but
with hidden variables carrying both
<computeroutput>note_id</computeroutput> and
<computeroutput>confirm_p</computeroutput>.  If confirm_p is present,
we delete the record, set redirection back to the index, and abort
script execution.</para>

      <para>The database commands:</para>
      <screen>[service0 www]$ <userinput>emacs note-delete.xql</userinput></screen>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="do_delete"&gt;
    &lt;querytext&gt;
      select samplenote__delete(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="get_name"&gt;
    &lt;querytext&gt;
      select samplenote__name(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>And the adp page:</para>
      <screen>[service0 www]$ <userinput>emacs note-delete.adp</userinput></screen>
      <programlisting>&lt;master&gt;
&lt;property name="title"&gt;@title@&lt;/property&gt;
&lt;property name="context"&gt;{@title@}&lt;/property&gt;
&lt;h2&gt;@title@&lt;/h2&gt;
&lt;formtemplate id="note-del-confirm"&gt;&lt;/formtemplate&gt;
&lt;/form&gt;</programlisting>
    <para>The ADP is very simple.  The
<computeroutput>formtemplate</computeroutput> tag outputs the HTML
form generated by the ad_form command with the matching name.  Test it by adding the new files in the APM and then deleting a few samplenotes.</para>
  </sect2>
  <sect2>
    <title>General_comments</title>
    <para>You can track comments for any ACS Object.  Here we'll track
    comments for notes.  On the notes.tcl/adp pair, which is used to
    display individual notes, we want to put a link to add comments at
    the bottom of the screen.  If there are any comments, we want to
    show them.</para>
    <para>First, we need to generate a url for adding comments.  In notes.tcl:</para>
    <programlisting>
set comment_add_url "[general_comments_package_url]comment-add?[export_vars {
 { object_id $note_id } 
 { object_name $title } 
 { return_url "[ad_conn url]?[ad_conn query]"} 
}]"
</programlisting>
    <para>This calls a global, public tcl function that the
    general_comments package registered, to get its url. You then
    embed in that url the id of the note and its title, and set the
    return_url to the current url so that the user can return after
    adding a comment.</para>
    <para>We need to create html that shows any existing comments.
    We do this with another general_comments function:</para>
    <programlisting>set comments_html [general_comments_get_comments
    -print_content_p 1 $note_id]</programlisting>
    <para>First, we pass in an optional parameter that that says to actually
    show the contents of the comments, instead of just the fact that
    there are comments. Then you pass the note id, which is also the
    acs_object id.</para>
    <para>We put our two new variables in the notes.adp
    page.</para>
    <programlisting>&lt;a href="@comment_add_url@"&gt;Add a comment&lt;/a&gt;
@comments_html@</programlisting>
  </sect2>

      <sect2>
        <title>Prepare the package for distribution.</title>
        <para>Browse to the package manager.  Click on
        <computeroutput><guilabel>tutorialapp</guilabel></computeroutput>.</para>
        <para>Click on <computeroutput><guilabel>Generate a distribution file
        for this package from the
        filesystem</guilabel></computeroutput>.
</para>
        <para>Click on the file size
        (<computeroutput><guilabel>37.1KB</guilabel></computeroutput>)
        after the label <computeroutput><guilabel>Distribution
        File:</guilabel></computeroutput> and save the file to
        /tmp.</para>
        <para><indexterm>
            <primary>The publish point for new packages should be
        fixed.</primary>
          </indexterm>
</para>
      </sect2>

</sect1>
