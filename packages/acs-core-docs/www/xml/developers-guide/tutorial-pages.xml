  <sect1 id="tutorial-pages">
  <title>Creating Web Pages</title>
  
  <authorblurb>
    by <ulink url="mailto:joel@aufrecht.org">Joel Aufrecht</ulink>
  </authorblurb>
  
  <sect2>
    <title>Build the "Index" page</title>
      <para>Each user-visible page in your package has, typically,
      three parts.  The <computeroutput>xql</computeroutput> file contains any database queries, the
      <computeroutput>tcl</computeroutput> file holds the procedural logic for the page and does things
      like check permissions, invoke the database queries, and modify
      variables, and the <computeroutput>adp</computeroutput> page
      holds html.  The default page in any directory is
      <computeroutput>index</computeroutput>, so we'll build that
      first, starting with the tcl file:
</para>
      <screen>[service0@yourserver samplenote]$<userinput> cd /web/service0/packages/samplenote/www</userinput>
[service0@yourserver www]$ <userinput>emacs index.tcl</userinput></screen>
      <para>Paste this into the file.  There are several things to
note about the file:</para>
      <itemizedlist>
        <listitem><para>The page begins with an
        <computeroutput><ulink url="/api-doc/proc-view?proc=ad%5fpage%5fcontract">ad_page_contract</ulink></computeroutput> function.
        This is where we declare the input and output variables and
        their types and restrictions.  It's also where we document the
        page, including descriptions of the parameters and return.</para>
        </listitem>
        <listitem>
          <para>We have one input variable,
          <computeroutput>orderby</computeroutput>, which is optional
          and defaults to <computeroutput>title</computeroutput>.</para>
        </listitem>
        <listitem>
          <para>We have one output variable, <computeroutput>table_html</computeroutput></para>
        </listitem>
        <listitem>
          <para>We populate the table_html variable with a function call, <computeroutput><ulink url="/api-doc/proc-view?proc=ad%5f_table">ad_table</ulink></computeroutput>, which does most of the work of generating an html table from a database recordset.  We pass it several parameters:</para>
          <variablelist>
            <varlistentry>
              <term>-Torderby $orderby</term>
              <listitem>
                <para>If the user has selected a column for sorting, this passes that information to the function.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>notes_query</term>
              <listitem>
                <para>This is the name of the SQL query that we'll put in the xql file.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>{ *SQL* }</term>
              <listitem>
                <para>This is a dummy placeholder.  It's possible to put sql directly in the tcl file, but this is deprecated because it's harder to make portable.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>$table_def</term>
              <listitem>
                <para>Here we pass in the variable we just constructed; it contains a list of column names and display titles.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </itemizedlist>
      
      <programlisting>ad_page_contract {
    This is the main page for the package.  It displays all of the Sample Notes\ and provides links to edit them and to create new Notes.

    @author rhs@mit.edu
    @creation-date 2000-10-23
    @cvs-id $Id$
    @param orderby indicates when the user clicks on a column to order by that \column
    @return table_html preformatting html table constructed by querying the sam\plenotes table

} {
    {orderby:optional {title}}
} -properties {
    table_html
}
# define the columns in the table
set table_def   {
    {title "Note"}
    {body "Contents"}
    {edit "" {} {&lt;td&gt;&lt;a href="note-edit?note_id=$note_id"&gt;Edit&lt;/a&gt;&lt;/td&gt;}}
    {delete "" {} {&lt;td&gt;&lt;a href="note-delete?note_id=$note_id"&gt;Delete&lt;/a&gt;&lt;/td&gt;}}
}

# construct an html table from the samplenotes database table
set table_html [ad_table -Torderby $orderby notes_query { *SQL* } $table_def]</programlisting>
      <para>Now put the database query into a separate file.  If the
      database query is exactly the same for Oracle and PostgreSQL, it
      can go into a file with the same name as the tcl file but an xql
      extension, e.g., <computeroutput>index.xql</computeroutput>.  If
      it is database-specific, it goes in
      <computeroutput>index-oracle.xql</computeroutput> or
      <computeroutput>index-postgresql.xql</computeroutput>.  The
      format is the same in each case, an XML structure that contains
      the SQL query.  Create the file now.</para>
      <screen>[service0@yourserver www]$<userinput> emacs index.xql</userinput></screen>
      <para>Note that the
      <computeroutput>name</computeroutput> parameter of the
      <computeroutput>fullquery</computeroutput> tag exactly matches
      the SQL query name specified in the
      <computeroutput>ad_table</computeroutput> call.  Also, the SQL query ends with a tcl function call that generates a SQL ORDER BY clause using several TCL variables.  </para>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="notes_query"&gt;
    &lt;querytext&gt;
    select note_id,
           title,
           body
      from samplenote
    [ad_order_by_from_sort_spec $orderby $table_def]
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>Now we create the user-visible page.</para>
      <screen>[service0@yourserver www]$ <userinput>emacs index.adp</userinput></screen>
      <para>The first line indicates that this page should be rendered within the the master template, which defaults to <computeroutput>/web/service0/www/default-master</computeroutput>.  The second line passes a <computeroutput>title</computeroutput> variable to the master template.  The third line inserts the contents of the variable <computeroutput>table_html</computeroutput>.  The last line is a link to a page we haven't created yet.</para>
      <programlisting>&lt;master&gt;
&lt;property name="title"&gt;Sample Notes&lt;/property&gt;
@table_html@
&lt;p&gt;&lt;a href="note-edit"&gt;Add a note&lt;/a&gt;&lt;/p&gt;</programlisting>
    </sect2>
    <sect2>
      <title>Add files to APM</title>
      <para>Before we can test these files, we have to notify the package manager that they exist.  (To be precise, the tcl and adp will work fine as-is, but the xql file will not be recognized until we tell the APM about it.).</para>
      <itemizedlist>
        <listitem><para> Go to <computeroutput>http://yourserver.test:8000/acs-admin/apm</computeroutput></para>
        </listitem>
        <listitem><para>Click on the <computeroutput>samplenote</computeroutput> link</para>
        </listitem>
        <listitem><para>Click <computeroutput>Manage file information</computeroutput></para>
        </listitem>
        <listitem>
          <para>Click <computeroutput>Scan the packages/samplenote directory for additional files in thispackage </computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput>add checked files</computeroutput></para>
        </listitem>
      </itemizedlist>
      <para>Now that the pages are in the APM, check to make sure that the self-documenting code is working.</para>
      <itemizedlist>
        <listitem><para>Browse to <computeroutput>http://yourserver:8000/api-doc/</computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput># Notes (Sample Application) 0.1d</computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput>Content Pages</computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput>index.tcl</computeroutput> and examine the results.</para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Test the index page</title>
      <para>Go to <computeroutput>http://192.168.0.2:8000/samplenote/</computeroutput>.  You should see something like this:</para>
      <screen>
Sample Notes
Your Workspace : Main Site : Sample Note 

No data found.

foo@yourserver.test
</screen>
      <para>Since our table is empty, it's a pretty boring page.  So next we'll make it possible to add records. </para>
      <para>If you get any other output, such as an error message, skip to <xref linkend="tutorial-debug"/>.  Note also that, while tcl and adp pages update automatically, xql pages get cached.  So if you change an xql page, the change won't take effect unless you restart the server, reload the package via the APM, or put a <emphasis>watch</emphasis> on the file in the APM file list.  With a watch, which lasts until the next service restart, the file will be updated each time it is changed on disk.</para>
    </sect2>
    <sect2>
      <title>Add the add/edit page</title>
      <para>We'll create a single page to handle both adding and editing records.  First, create the tcl:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-edit.tcl</userinput></screen>
      <para>The page takes a single, optional input parameter, note_id.  If it's present, logic within <computeroutput><ulink url="/api-doc/proc-view?proc=ad_form">ad_form</ulink></computeroutput> will assume that we're editing an existing record.  We check user_id with <computeroutput><ulink url="/api-doc/proc-view?proc=ad_maybe_redirect_for_registration">ad_maybe_redirect_for_registration</ulink></computeroutput>, which will redirect to the login page (with an automatic return path to bring them back after login or registration) if the visitor isn't logged in.  Then we call ad_form, specifying the primary key of the table, the fields we want to edit, and functions for insert and update.</para>
      <programlisting>ad_page_contract {
        Simple add/edit form for samplenote.
} {
    note_id:optional
}
set user_id [ad_maybe_redirect_for_registration]

ad_form -name note -form {
    note_id:key
    {title:text
        {label "Title"}
    }
    {body:text(textarea)
        {label "Body"}
    }
} -select_query_name note_query -new_data {
db_1row do_insert { *SQL* }
} -edit_data {
db_dml do_update { *SQL* }
} -after_submit {
ad_returnredirect "index"
ad_script_abort
}</programlisting>
      <para>Next, we create the database functions.</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-edit.xql</userinput></screen>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="do_insert"&gt;
    &lt;querytext&gt;
        select samplenote__new(:title, :body,null,:user_id,null,null)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="do_update"&gt;
    &lt;querytext&gt;
       update samplenote
          set title = :title,
              body = :body
        where note_id = :note_id
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="note_query"&gt;
    &lt;querytext&gt;
      select title,
             body
        from samplenote
       where note_id = :note_id
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>And now the user-visible page:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-edit.adp</userinput></screen>
      <programlisting>&lt;master&gt;
&lt;formtemplate id="note"&gt;&lt;/formtemplate&gt;
</programlisting>
      <para>Go to the APM as before and scan for new files and add your new work.  Then test all this by going to the package home page and adding and editing a few records.</para>
    </sect2>
    <sect2>
      <title>A Deletion page</title>
      <para>Now we need a way to delete records.  We'll create a recursive confirmation page.</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-delete.tcl</userinput></screen>
      <para>This page requires a <computeroutput>note_id</computeroutput> to determine which record should be deleted.  It also looks for a confirmation variable, which should initially be absert.  If it is absent, we create a form to allow the user to confirm the deletion.  The form calls the same page, but with hidden variables carrying both <computeroutput>note_id</computeroutput> and <computeroutput>confirm_p</computeroutput>.</para>
      <programlisting>ad_page_contract {
    A page that gets confirmation and then delete notes.

    @author joel@aufrecht.org
    @creation-date 2003-02-12
    @cvs-id $Id$
} {
    note_id:integer
    confirm_p:optional
}

set title "Delete Note"

if {[exists_and_not_null confirm]} {
    # if confirmed, call the database to delete the record
    db_1row do_delete { *SQL* }
    ad_returnredirect "index"
} else {
    # if not confirmed, display a form for confirmation
    set note_name [db_string get_name { *SQL }]
    set title "Delete $note_name"
    template::form::create note-del-confirm
    template::element::create note-del-confirm note_id -value $note_id -widget \hidden
    template::element::create note-del-confirm confirm_p -value 1 -widget hidden
}</programlisting>
      <para>Now the database calls:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-delete.xql</userinput></screen>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="do_delete"&gt;
    &lt;querytext&gt;
      select samplenote__delete(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="get_name"&gt;
    &lt;querytext&gt;
      select samplenote__name(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>And the adp page:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-delete.adp</userinput></screen>
      <programlisting>&lt;master&gt;
&lt;property name="title"&gt;@title@&lt;/property&gt;
&lt;h2&gt;@title@&lt;/h2&gt;
&lt;formtemplate id="note-del-confirm"&gt;&lt;/formtemplate&gt;
&lt;/form&gt;</programlisting>
      <para>Now test it by adding the new files in the APM and then deleting a few samplenotes.</para>
    </sect2>
    <sect2>
      <title>Adding files to cvs</title>
      <para>Put your new work into source control.</para>
      <screen>[service0@yourserver www]$ <userinput>cvs add *.adp *.tcl *.xql</userinput>
cvs add: cannot add special file `CVS'; skipping
cvs add: doc/CVS already exists
cvs add: scheduling file `index.adp' for addition
cvs add: scheduling file `index.tcl' for addition
cvs add: scheduling file `index.xql' for addition
cvs add: scheduling file `note-delete.adp' for addition
cvs add: scheduling file `note-delete.tcl' for addition
cvs add: scheduling file `note-delete.xql' for addition
cvs add: scheduling file `note-edit.adp' for addition
cvs add: scheduling file `note-edit.tcl' for addition
cvs add: scheduling file `note-edit.xql' for addition
cvs add: use 'cvs commit' to add these files permanently
[service0@yourserver www]$ <userinput> cvs commit -m "new work"</userinput>
/cvsroot/service0/packages/samplenote/www/note-edit.xql~,v  &lt;--  note-edit.xql
<emphasis>(many lines omitted)</emphasis>
initial revision: 1.1
done
[service0@yourserver www]$</screen>
    </sect2>
  </sect1>

<!--
       Local Variables:
       sgml-parent-document: ("../index.xml" "book" "chapter")
       End:
-->
