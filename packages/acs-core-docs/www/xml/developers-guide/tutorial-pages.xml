<?xml version='1.0' ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY % myvars SYSTEM "../variables.ent">
%myvars;
]>
  <sect1 id="tutorial-pages">
  <title>Creating Web Pages</title>
  
  <authorblurb>
    by <ulink url="mailto:joel@aufrecht.org">Joel Aufrecht</ulink>
  </authorblurb>
  
  <sect2>
    <title>Build the "Index" page</title>
      <para>Each user-visible page in your package has, typically,
      three parts.  The <computeroutput>xql</computeroutput> file contains any database queries, the
      <computeroutput>tcl</computeroutput> file holds the procedural logic for the page and does things
      like check permissions, invoke the database queries, and modify
      variables, and the <computeroutput>adp</computeroutput> page
      holds html.  The default page in any directory is
      <computeroutput>index</computeroutput>, so we'll build that
      first, starting with the tcl file:
</para>
      <screen>[service0@yourserver postgresql]$<userinput> cd /var/lib/aolserver/service0/myfirstpackages/www</userinput>
[service0@yourserver www <userinput>emacs index.tcl</userinput></screen>
      <para>Paste this into the file.</para>      
      <programlisting>ad_page_contract {
    This is the main page for the package.  It displays all of the Notes and provides links to edit them and to create new Notes.

    @author rhs@mit.edu
    @creation-date 2000-10-23
    @cvs-id $Id$
    @param orderby indicates when the user clicks on a column to order by that \column
    @return table_html preformatting html table constructed by querying the sam\plenotes table

} {
    {orderby:optional {title}}
} -properties {
    table_html
}
# define the columns in the table
set table_def   {
    {title "Note"}
    {body "Contents"}
    {edit "" {} {&lt;td&gt;&lt;a href="note-edit?note_id=$note_id"&gt;Edit&lt;/a&gt;&lt;/td&gt;}}
}

# construct an html table from the samplenotes database table
set table_html [ad_table -Torderby $orderby notes_query { *SQL* } $table_def]</programlisting>
<para>  There are several things to
note about the file:</para>
      <itemizedlist>
        <listitem><para>The page begins with an
        <computeroutput><ulink url="/api-doc/proc-view?proc=ad%5fpage%5fcontract">ad_page_contract</ulink></computeroutput> function.
        This is where we declare the input and output variables and
        their types and restrictions.  It's also where we document the
        page, including descriptions of the parameters and return.
        (<ulink url="/doc/tcl-doc.html">More information about TCL
        pages and page contracts</ulink>)</para>
        </listitem>
        <listitem>
          <para>We have one input variable,
          <computeroutput>orderby</computeroutput>, which is optional
          and defaults to <computeroutput>title</computeroutput>.</para>
        </listitem>
        <listitem>
          <para>We have one output variable, <computeroutput>table_html</computeroutput></para>
        </listitem>
        <listitem>
          <para>We populate the table_html variable with a function call, <computeroutput><ulink url="/api-doc/proc-view?proc=ad%5f_table">ad_table</ulink></computeroutput>, which does most of the work of generating an html table from a database recordset.  We pass it several parameters:</para>
          <variablelist>
            <varlistentry>
              <term>-Torderby $orderby</term>
              <listitem>
                <para>If the user has selected a column for sorting, this passes that information to the function.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>notes_query</term>
              <listitem>
                <para>This is the name of the SQL query that we'll put in the xql file.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>{ *SQL* }</term>
              <listitem>
                <para>This is a dummy placeholder.  It's possible to put sql directly in the tcl file, but this is deprecated because it's harder to make portable.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>$table_def</term>
              <listitem>
                <para>Here we pass in the variable we just constructed; it contains a list of column names and display titles.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </itemizedlist>
      <para>Put the database query into a separate file.  If the
      database query is exactly the same for Oracle and PostgreSQL, it
      can go into a file with the same name as the tcl file but an xql
      extension, e.g., <computeroutput>index.xql</computeroutput>.  If
      it is database-specific, it goes in
      <computeroutput>index-oracle.xql</computeroutput> or
      <computeroutput>index-postgresql.xql</computeroutput>.  The
      format is the same in each case, an XML structure that contains
      the SQL query.  Create the file now.</para>
      <screen>[service0@yourserver www]$<userinput> emacs index.xql</userinput></screen>
      <para>Note that the
      <computeroutput>name</computeroutput> parameter of the
      <computeroutput>fullquery</computeroutput> tag exactly matches
      the SQL query name specified in the
      <computeroutput>ad_table</computeroutput> call.  Also, the SQL query ends with a tcl function call that generates a SQL ORDER BY clause using several TCL variables.  </para>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="notes_query"&gt;
    &lt;querytext&gt;
    select note_id,
           title,
           body
      from samplenote
    [ad_order_by_from_sort_spec $orderby $table_def]
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>Create the user-visible page.</para>
      <screen>[service0@yourserver www]$ <userinput>emacs index.adp</userinput></screen>
      <para>The first line indicates that this page should be rendered within the the master template, which defaults to <computeroutput>/web/service0/www/default-master</computeroutput>.  The second line passes a <computeroutput>title</computeroutput> variable to the master template.  The third line inserts the contents of the variable <computeroutput>table_html</computeroutput>.  The last line is a link to a page we haven't created yet.</para>
      <programlisting>&lt;master&gt;
&lt;property name="title"&gt;Sample Notes&lt;/property&gt;
@table_html@
&lt;p&gt;&lt;a href="note-edit"&gt;Add a note&lt;/a&gt;&lt;/p&gt;</programlisting>
    </sect2>
    <sect2>
      <title>Making the APM load your files</title>
      <para>Before we can test these files, we have to notify the
      package manager that they exist.  (More precisely, the tcl and
      adp will work fine as-is, but the xql file will not be
      recognized until we tell the APM about it.).</para>
      <itemizedlist>
        <listitem><para> Go to <computeroutput>http://yourserver.test:8000/acs-admin/apm</computeroutput></para>
        </listitem>
        <listitem><para>Click on the <computeroutput>samplenote</computeroutput> link</para>
        </listitem>
        <listitem><para>Click <computeroutput>Manage file information</computeroutput></para>
        </listitem>
        <listitem>
          <para>
            Check the values in the file type column for your files. A
            question mark means the APM doesn't recognize the file
            type and probably means you have mistyped a filename.
          </para>
        </listitem>

        <listitem>
          <para>
            At the bottom of the file list page - click on the
            <computeroutput>watch all files</computeroutput> link.
            Unlike adp and tcl pages, xql pages get cached.  (And new
            xql files don't get loaded when they're watched or the
            server is restarted.)  Watching an xql file causes the APM
            to load the contents of the XQL into memory so that it can
            be used, and to reload it whenever the file is changed.
            The watch will last until the server is restarted.
          </para>
        </listitem>

      </itemizedlist>
      <para>Now that the APM is aware of your files, check to make sure that the self-documenting code is working.</para>
      <itemizedlist>
        <listitem><para>Browse to <computeroutput>http://yourserver.test:8000/api-doc/</computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput>Notes 0.1d</computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput>Content Pages</computeroutput></para>
        </listitem>
        <listitem><para>Click <computeroutput>index.tcl</computeroutput> and examine the results.</para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Test the index page</title>
      <para>Go to <computeroutput>http://<replaceable>yourserver.test:8000</replaceable>/note/</computeroutput>.  You should see this:</para>
      <screen>
Sample Notes
Your Workspace : Main Site : Sample Note 

No data found.

Add a note.

foo@yourserver.test
</screen>
      <para>Since our table is empty, it's a pretty boring page.  So next we'll make it possible to add records. </para>
      <para>If you get any other output, such as an error message, skip to <xref linkend="tutorial-debug"/>.</para>
    </sect2>
    <sect2>
      <title>Add the add/edit page</title>
      <para>We'll create a single page to handle both adding and
      editing records.  In this recursive approach, the same tcl
      function can present a blank HTML form, present the same form
      pre-loaded with an existing record, and handle the resulting
      submission of either updated or new records.  This recursive
      approach reduces the total amount of code and files.  First,
      create the tcl:</para>

      <screen>[service0@yourserver www]$ <userinput>emacs note-edit.tcl</userinput></screen>
      <para>Paste and save and edit:</para>
      <programlisting>ad_page_contract {
        Simple add/edit form for samplenote.
} {
    note_id:integer,optional
}
set user_id [ad_maybe_redirect_for_registration]
set title "Add a note"

if {[exists_and_not_null note_id]} {
    set title "Edit a note"
}

ad_form -name note -form {
    note_id:key
    {title:text
        {label "Title"}
    }
    {body:text(textarea)
        {label "Body"}
    }
} -select_query_name note_query -new_data {
db_1row do_insert { *SQL* }
} -edit_data {
db_dml do_update { *SQL* }
} -after_submit {
ad_returnredirect "index"
}</programlisting>
      <para>We use <computeroutput><ulink
    url="/api-doc/proc-view?proc=ad_form">ad_form</ulink></computeroutput>
    to automate most of the work here.  Ad_form is a wrapper for the
    <ulink url="/api-doc/proc-view?proc=template%3a%3aform">template
    functions</ulink> for creating HTML forms.  These functions should
    always be used for HTML forms; this promotes consistency and,
    since all template functions use the same stylesheet system, makes it easy to change
    the appearance of forms.  </para>
      <para>The page takes a single, optional input parameter,
    note_id.  If it's present, ad_form will assume that we're editing
    an existing record, look up that record, and pre-populate the
    form.  We'll also check and change the page title if necessary.  We check user_id with <computeroutput><ulink
    url="/api-doc/proc-view?proc=ad_maybe_redirect_for_registration">ad_maybe_redirect_for_registration</ulink></computeroutput>,
    which will redirect to the login page (with an automatic return
    path to bring them back after login or registration) if the
    visitor isn't logged in.  Then we call ad_form, specifying the
    primary key of the table, the fields we want to edit, and
    functions for insert and update.</para>
      <para>Next, we create the database functions.</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-edit.xql</userinput></screen>
      <programlisting>&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="do_insert"&gt;
    &lt;querytext&gt;
        select samplenote__new(null,:title, :body,null,:user_id,null,null)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="do_update"&gt;
    &lt;querytext&gt;
       update samplenote
          set title = :title,
              body = :body
        where note_id = :note_id
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="note_query"&gt;
    &lt;querytext&gt;
      select title,
             body
        from samplenote
       where note_id = :note_id
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</programlisting>
      <para>Create the user-visible page:</para>
      <screen>[service0@yourserver www]$ <userinput>emacs note-edit.adp</userinput></screen>
      <programlisting>&lt;master&gt;
&lt;property name="title"&gt;@title@&lt;/property&gt;
&lt;property name="context"&gt;{@title@}&lt;/property&gt;
&lt;formtemplate id="note"&gt;&lt;/formtemplate&gt;
</programlisting>
      <para>The property tags are passed to the master template, which
      uses their values to set the page title and context bar
      (breadcrumb trail).  We use the same variable,
      <computeroutput>title</computeroutput>, for both variables but
      wrap it in curly brackets for context so that the spaces aren't
      interpreted separators.  The formtemplate tag outputs the form
      html with the matching name.</para>
      <para>Go to the APM as before and reload.  Then test all this by going to the package home page and adding and editing a few records.</para>
    </sect2>
    <sect2>
      <title>Adding files to cvs</title>
      <para>Put your new work into source control.</para>
      <screen>[service0@yourserver www]$ <userinput>cvs add *.adp *.tcl *.xql</userinput>
cvs add: cannot add special file `CVS'; skipping
cvs add: doc/CVS already exists
cvs add: scheduling file `index.adp' for addition
cvs add: scheduling file `index.tcl' for addition
cvs add: scheduling file `index.xql' for addition
cvs add: scheduling file `note-edit.adp' for addition
cvs add: scheduling file `note-edit.tcl' for addition
cvs add: scheduling file `note-edit.xql' for addition
cvs add: use 'cvs commit' to add these files permanently
[service0@yourserver www]$ <userinput> cvs commit -m "new work"</userinput>
/cvsroot/service0/packages/samplenote/www/note-edit.xql~,v  &lt;--  note-edit.xql
<emphasis>(many lines omitted)</emphasis>
initial revision: 1.1
done
[service0@yourserver www]$</screen>
    </sect2>
  </sect1>

