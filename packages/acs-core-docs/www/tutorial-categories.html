<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Categories</title><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><link rel="home" href="index.html" title="OpenACS Core Documentation"><link rel="up" href="tutorial-advanced.html" title="Chapter 10. Advanced Topics"><link rel="previous" href="tutorial-admin-pages.html" title="Admin Pages"><link rel="next" href="ch10s06.html" title="Categories"><link rel="stylesheet" href="openacs.css" type="text/css"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><a href="http://openacs.org"><img src="/doc/images/alex.jpg" border="0" alt="Alex logo"></a><table width="100%" summary="Navigation header" border="0"><tr><td width="20%" align="left"><a accesskey="p" href="tutorial-admin-pages.html">Prev</a> </td><th width="60%" align="center">Chapter 10. Advanced Topics</th><td width="20%" align="right"> <a accesskey="n" href="ch10s06.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-categories"></a>Categories</h2></div></div><div></div></div><p>You can associate any ACS Object with one or more categories.
    In this tutorial we'll show how to equip your application with user
    interface to take advantage of the Categories service.
    </p><p>
    We'll start by installing the Categories service.  Go to
    <tt class="computeroutput">/acs/admin</tt> and install it.  This step
    won't be necessary for the users of your applications because you'll create
    a dependency with the Package Manager which will take care that the
    Categories service always gets installed when your application gets
    installed.
    </p><p>
    Now that we have installed the Categories service we can proceed to
    modifying our application so that it can take advantage of it.  We'll do it
    in three steps:
    </p><div class="orderedlist"><ol type="1"><li><p>
          The Categories service provides a mechanism to associate one or
          more <span class="emphasis"><em>category trees</em></span> that are relevant to
          your application.  One example of such tree is a tree of
          geographical locations.  Continents are on the top of such tree,
          each continent containing countries etc.  Another tree might
          contain market segments etc.  Before users of your application
          can take advantage of the Categories service there needs to be a
          way for administrators of your application to choose which
          category trees are applicable for the application.
          </p><p>
          The way to achieve this is is to provide a link
          to the Category Management pages.  Add the following snippet to your
            <tt class="computeroutput">/var/lib/aolserver/<span class="replaceable"><span class="replaceable">service0</span></span>/packages/myfirstpackage/www/admin/index.tcl</tt>
          file:
          </p><pre class="programlisting">
set category_map_url [export_vars -base \
    "[site_node::get_package_url -package_key categories]cadmin/one-object" \
        { { object_id $package_id } }]
          </pre><p>
          and the following snippet to your
            <tt class="computeroutput">/var/lib/aolserver/<span class="replaceable"><span class="replaceable">service0</span></span>/packages/myfirstpackage/www/admin/index.adp</tt>
          file:
          </p><pre class="programlisting">
&lt;li&gt;&lt;a href="@category_map_url@"
      class="action_link"&gt;Site-Wide Categories&lt;/a&gt;
          </pre><p>The link created by the above code will take the admin to the generic
          admin UI where he can pick category trees that make sense for this
          application.  The same UI also includes facilities to build and edit
          category trees.  Notice that the only parameter in this example is
          <tt class="computeroutput">package_id</tt> so that category trees
          will be associated with the object identified by this
          <tt class="computeroutput">package_id</tt>.  The categorization
          service is actually more general than that: instead of
          <tt class="computeroutput">package_id</tt> you could use an ID of
          some other object that serves as a "container" in your application.
          For example, if your discussion forums application supports multiple
          forums you would use <tt class="computeroutput">forum_id</tt> to
          associate category trees with just that one forum rather than the
          entire application instance.
        </p></li><li><p>
          Once the category trees have been selected users need a way
          to categorize items.  The easiest way to do this is by adding the
          <tt class="computeroutput">category</tt> widget type of the
          form builder to <tt class="computeroutput">note-edit.tcl</tt>.
          To achieve this we'll need to use the <tt class="computeroutput">-extend</tt>
          switch to the <tt class="computeroutput">ad_form</tt> command. Here's the "meat" of the
          <tt class="computeroutput">note-edit.tcl</tt> page:</p><pre class="programlisting">
ad_form -name note -form {
    {item_id:key}
    {title:text {label Title}}
}

set package_id [ad_conn package_id]

set category_trees [category_tree::get_mapped_trees $package_id]

foreach tree $category_trees {
    foreach { tree_id name subtree_id } $tree {}
    ad_form -extend -name note -form \
        [list [list category_id_${tree_id}:integer(category),optional \
                   {label $name} \
                   {html {single single}} \
                   {category_tree_id $tree_id} \
                   {category_subtree_id $subtree_id} \
                   {category_object_id {[value_if_exists entry_id]}}]]
}

ad_form -extend \
  -name note \
  -new_request {
    permission::require_permission -object_id [ad_conn package_id] -privilege create
    set page_title "Add a Note"
    set context [list $page_title]
} -edit_request {
    permission::require_write_permission -object_id $item_id
    mfp::note::get \
    -item_id $item_id \
    -array note_array

    set title $note_array(title)

    set page_title "Edit a Note"
    set context [list $page_title]
} -new_data {
    mfp::note::add \
    -title $title
} -after_submit {
    ad_returnredirect "."
    ad_script_abort
}</pre><p>This page requires a
<tt class="computeroutput">note_id</tt> to determine which record
should be deleted.  It also looks for a confirmation variable, which
should initially be absert.  If it is absent, we create a form to
allow the user to confirm the deletion.  Note that in
<tt class="computeroutput">entry-edit.tcl</tt> we used <tt class="computeroutput">ad_form</tt> to access the Form Template
commands; here, we call them directly because we don't need the extra
features of ad_form.  The form calls itself, but
with hidden variables carrying both
<tt class="computeroutput">note_id</tt> and
<tt class="computeroutput">confirm_p</tt>.  If confirm_p is present,
we delete the record, set redirection back to the index, and abort
script execution.</p><p>The database commands:</p><pre class="screen">[service0@yourserver www]$ <b class="userinput"><tt>emacs note-delete.xql</tt></b></pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;queryset&gt;
  &lt;fullquery name="do_delete"&gt;
    &lt;querytext&gt;
      select samplenote__delete(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
  &lt;fullquery name="get_name"&gt;
    &lt;querytext&gt;
      select samplenote__name(:note_id)
    &lt;/querytext&gt;
  &lt;/fullquery&gt;
&lt;/queryset&gt;</pre><p>And the adp page:</p><pre class="screen">[service0@yourserver www]$ <b class="userinput"><tt>emacs note-delete.adp</tt></b></pre><pre class="programlisting">&lt;master&gt;
&lt;property name="title"&gt;@title@&lt;/property&gt;
&lt;property name="context"&gt;{@title@}&lt;/property&gt;
&lt;h2&gt;@title@&lt;/h2&gt;
&lt;formtemplate id="note-del-confirm"&gt;&lt;/formtemplate&gt;
&lt;/form&gt;</pre><p>The ADP is very simple.  The
<tt class="computeroutput">formtemplate</tt> tag outputs the HTML
form generated by the ad_form command with the matching name.  Test it
      by adding the new files in the APM and then deleting a few
      samplenotes.</p></li></ol></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial-admin-pages.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right"> <a accesskey="n" href="ch10s06.html">Next</a></td></tr><tr><td width="40%" align="left">Admin Pages </td><td width="20%" align="center"><a accesskey="u" href="tutorial-advanced.html">Up</a></td><td width="40%" align="right"> Categories</td></tr></table><hr><address><a href="mailto:docs@openacs.org">docs@openacs.org</a></address></div><a name="comments"></a><center><a href="http://openacs.org/doc/current/tutorial-categories.html#comments">View comments on this page at openacs.org</a></center></body></html>
