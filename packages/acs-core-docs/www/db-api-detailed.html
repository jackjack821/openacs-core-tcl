<html xmlns:lxslt="http://xml.apache.org/xslt" xmlns:saxon="http://icl.com/saxon" xmlns:xalanredirect="org.apache.xalan.xslt.extensions.Redirect"><head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>17. Database Access API</title><link rel="stylesheet" href="ad.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.24"><link rel="home" href="index.html" title="ACS Core"><link rel="up" href="kernel-doc.html" title="7. Kernel Documentation"><link rel="previous" href="rp-design.html" title="16. ACS 4 Request Processor Design"><link rel="next" href="tcl-doc.html" title="18. Documenting Tcl Files: Page Contracts and Libraries"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><a href="http://www.openacs.org/"><img src="images/alex.jpg" border="0"></a><br><br><a class="topnav" href="/">Home</a><span class="topnav"> : </span><a class="topnav" href="index">Documentation</a><span class="topnav"> : </span><a class="topnav" href="acs-dev.html">Part III. For ACS Developers</a><span class="topnav"> : </span><a class="topnav" href="kernel-doc.html">7. Kernel Documentation</a><span class="topnav"> : </span><strong class="topnav">17. Database Access API&nbsp;</strong><hr size="1" noshade><div id="db-api-detailed" class="sect1"><div class="titlepage"><h2 class="title" style="clear: all"><a name="db-api-detailed"></a><span class="label">17.</span> <span class="title">Database Access API</span></h2></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt>17.1. <a href="db-api-detailed.html#db-api-detailed-bigpicture">The Big Picture</a></dt><dt>17.2. <a href="db-api-detailed.html#db-api-detailed-set-var-aft-query">The Bell Tolls for <tt>set_variables_after_query</tt></a></dt><dt>17.3. <a href="db-api-detailed.html#db-api-detailed-handles">Handle Management</a></dt><dt>17.4. <a href="db-api-detailed.html#db-api-detailed-bindvars">Bind Variables</a></dt><dt>17.5. <a href="db-api-detailed.html#db-api-detailed-sql-abstraction">SQL Abstraction</a></dt><dt>17.6. <a href="db-api-detailed.html#db-api-detailed-placing-values">Placing Column Values in Arrays and Sets</a></dt><dt>17.7. <a href="db-api-detailed.html#db-api-detailed-pooling">Sequence Pooling</a></dt><dt>17.8. <a href="db-api-detailed.html#dp-api-detailed-api">API</a></dt></dl></div><p><p>
by <a href="mailto:jsalz@mit.edu" target="_top">Jon Salz</a> 
</p></p><div class="itemizedlist"><ul><li><a name="N19462"></a><p>Tcl procedures: /packages/acs-kernel/10-database-procs.tcl</p></li><li><a name="N19465"></a><p>Tcl initialization: /packages/acs-kernel/database-init.tcl</p></li></ul></div><div id="db-api-detailed-bigpicture" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-bigpicture"></a><span class="label">17.1.</span> <span class="title">The Big Picture</span></h3></div><p>
One of ACS's great strengths is that code written for it is very close to
the database. It is very easy to interact with the database from anywhere
within ACS. Our goal is to develop a coherent API for database access which
makes this even easier. 
</p><p>There were four significant problems with the way ACS previously used the
database (i.e., directly through the <tt>ns_db</tt> interface):</p><div class="orderedlist"><ol type="1"><li><a name="N19483"></a><p><strong>Handle management</strong>. We required code to pass database
handles around, and for routines which needed to perform database access but
didn't receive a database handle as input, it was difficult to know from
which of the three "magic pools" (main, subquery, and log) to
allocate a new handle. 


</p></li><li><a name="N19488"></a><p><strong>Nested transactions</strong>. In our Oracle driver, <tt>begin
transaction</tt> really means "turn auto-commit mode off" and
<tt>end transaction</tt> means "commit the current transaction and
turn auto-commit mode on." Thus if transactional code needed to call a
routine which needed to operate transactionally, the semantics were
non-obvious. Consider: </p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

proc foo { db args } {
    db_transaction {
      ...
    }
}

db_transaction {
db_dml unused "insert into greeble(bork) values(33)"
foo $db
db_dml unused "insert into greeble(bork) values(50)"
}

</pre></td></tr></table></blockquote><p>
This would insert greeble #33 and do all the stuff in <tt>foo</tt>
transactionally, but the <tt>end transaction</tt> in <tt>foo</tt>
would actually cause a commit, and greeble #50 would later be inserted in
auto-commit mode. This could cause subtle bugs: e.g., in the case that the
insert for greeble #50 failed, part of the "transaction" would have
already have been committed!. This is not a good thing. 


</p></li><li><a name="N19518"></a><p><strong>Unorthodox use of variables</strong>. The standard mechanism for
mapping column values into variables involved the use of the
<tt>set_variables_after_query</tt> routine, which relies on an uplevel
variable named <tt>selection</tt> (likewise for
<tt>set_variables_after_subquery</tt> and <tt>subselection</tt>). 


</p></li><li><a name="N19539"></a><p><strong>Hard-coded reliance on Oracle</strong>. It's difficult to
write code supporting various different databases (dynamically using the
appropriate dialect based on the type of database being used, e.g., using
<tt>DECODE</tt> on Oracle and <tt>CASE ... WHEN</tt> on
Postgres).</p></li></ol></div><p>
The Database Access API addresses the first three problems by: 
</p><div class="orderedlist"><ol type="1"><li><a name="N19557"></a><p>making use of database handles transparent</p></li><li><a name="N19560"></a><p>wrapping common database operations (including transaction management) in
Tcl control structures (this is, after all, what Tcl is good at!)</p></li></ol></div><p>
It lays the groundwork for addressing the fourth problem by assigning each
SQL statement a logical name. In a future version of the ACS Core, this API
will translate logical statement names into actual SQL, based on the type of
database in use. (To smooth the learning curve, we provide a facility for
writing SQL inline for a "default SQL dialect", which we assume to
be Oracle for now.) 
</p><p>To be clear, SQL abstraction is <i>not</i> fully implemented in ACS
3.3.1. The statement names supplied to each call are not used by the API at
all. The API's design for SQL abstraction is in fact incomplete;
unresolved issues include:</p><div class="itemizedlist"><ul><li><a name="N19571"></a><p>how to add <tt>WHERE</tt> clause criteria dynamically</p></li><li><a name="N19578"></a><p>how to build a dynamic <tt>ORDER BY</tt> clause (Ben Adida has a
proposed solution for this)</p></li><li><a name="N19585"></a><p>how to define a statement's formal interface (i.e., what bind
variables it expects, what columns its <tt>SELECT</tt> clause must
contain if it's a query) without actually implementing the statement in a
specific SQL dialect</p></li></ul></div><p>
So why is the incremental change of adding statement naming to the API worth
the effort? It is worth the effort because we know that giving each SQL
statement a logical name will be required by the complete SQL abstraction
design. Therefore, we know that the effort will not be wasted, and taking
advantage of the new support for bind variables will already require code
that uses 3.3.0 version of the API to be updated. 
</p></div><div id="db-api-detailed-set-var-aft-query" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-set-var-aft-query"></a><span class="label">17.2.</span> <span class="title">The Bell Tolls for <tt>set_variables_after_query</tt></span></h3></div><p>
<tt>set_variables_after_query</tt> is gone! (Well, it's still there,
but you'll never need to use it.) The new API routines set local
variables automatically. For instance: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_1row select_names "select first_names, last_name from users where user_id = [ad_get_user_id]"
doc_body_append "Hello, $first_names $last_name!"

</pre></td></tr></table></blockquote><p>
Like <tt>ns_db 1row</tt>, this will bomb if the query doesn't return
any rows (no such user exists). If this isn't what you want, you can
write: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

if { [db_0or1row select_names "select first_names, last_name from users where user_id = [ad_get_user_id]"] } {
    doc_body_append "Hello, $first_names $last_name!"
} else {
    # Executed if the query returns no rows.
    doc_body_append "There's no such user!"
}

</pre></td></tr></table></blockquote><p>
Selecting a bunch of rows is a lot prettier now: 

 </p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_foreach select_names "select first_names, last_name from users" {
     doc_body_append "Say hi to $first_names $last_name for me!&lt;br&gt;"
}

</pre></td></tr></table></blockquote><p>
That's right, <tt>db_foreach</tt> is now like <tt>ns_db
select</tt> plus a <tt>while</tt> loop plus
<tt>set_variables_after_query</tt> plus an <tt>if</tt> statement
(containing code to be executed if no rows are returned). 

 </p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_foreach select_names "select first_names, last_name from users where last_name like 'S%'" {
     doc_body_append "Say hi to $first_names $last_name for me!&lt;br&gt;"
} if_no_rows {
     doc_body_append "There aren't any users with last names beginnings with S!"
}

</pre></td></tr></table></blockquote></div><div id="db-api-detailed-handles" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-handles"></a><span class="label">17.3.</span> <span class="title">Handle Management</span></h3></div><p>
The new API keeps track of which handles are in use, and automatically
allocates new handles when they are necessary (e.g., to perform subqueries
while a select is active). For example: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

doc_body_append "&lt;ul&gt;"
db_foreach select_names "select first_names, last_name, user_id from users" {
    # Automatically allocated a database handle from the main pool.
    doc_body_append "&lt;li&gt;User $first_names $last_name\n&lt;ul&gt;"

    db_foreach select_groups "select group_id from user_group_map where user_id = $user_id" {
        # There's a selection in progress, so we allocated a database handle
        # from the subquery pool for this selection.
        doc_body_append "&lt;li&gt;Member of group #$group_id.\n"
    } if_no_rows {
        # Not a member of any groups.
        doc_body_append "&lt;li&gt;Not a member of any group.\n"
    }
}
doc_body_append "&lt;/ul&gt;"
db_release_unused_handles

</pre></td></tr></table></blockquote><p>
A new handle isn't actually allocated and released for every selection,
of course - as a performance optimization, the API keeps old handles around
until <tt>db_release_unused_handles</tt> is invoked (or the script
terminates). 
</p><p>Note that there is no analogue to <tt>ns_db gethandle</tt> - the
handle is always automatically allocated the first time it's needed.</p></div><div id="db-api-detailed-bindvars" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-bindvars"></a><span class="label">17.4.</span> <span class="title">Bind Variables</span></h3></div><p><strong>Introduction</strong></p><p>
Most SQL statements require that the code invoking the statement pass along
data associated with that statement, usually obtained from the user. For
instance, in order to delete a WimpyPoint presentation, a Tcl script might
use the SQL statement 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

delete from wp_presentations where presentation_id = <i>some_presentation_id</i>

</pre></td></tr></table></blockquote><p>
where <i><tt>some_presentation_id</tt></i> is a number which is a valid
presentation ID of the presentation I want to delete. It's easy to write
code handling situations like this since SQL statements can include
<strong>bind variables</strong>, which represent placeholders for actual
data. A bind variable is specified as a colon followed by an identifier, so
the statement above can be coded as: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_dml presentation_delete {
    delete from wp_presentations where presentation_id = :some_presentation_id
}

</pre></td></tr></table></blockquote><p>
When this SQL statement is invoked, the value for the bind variable
<tt>:some_presentation_id</tt> is pulled from the Tcl variable
<tt>$some_presentation_id</tt> (in the caller's environment). Note
that bind variables are not limited to one per statement; you can use an
arbitrary number, and each will pull from the correspondingly named Tcl
variable. (Alternatively, you can also specify an list or <tt>ns_set</tt>
providing bind variables' values; see <i>Usage</i>.) 
</p><p>The value of a bind variable is taken literally by the database driver, so
there is never any need to put single-quotes around the value for a bind
variable, or to use <tt>db_quote</tt> to escape single-quotes contained
in the value. The following works fine, despite the apostrophe:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

set exclamation "That's all, folks!"
db_dml exclamation_insert { insert into exclamations(exclamation) values(:exclamation) }

</pre></td></tr></table></blockquote><p>Note that you can use a bind variable in a SQL statement only where you
could use a literal (a number or single-quoted string). Bind variables cannot
be placeholders for things like SQL keywords, table names, or column names,
so the following will not work, even if <tt>$table_name</tt> is set
properly:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

select * from :table_name

</pre></td></tr></table></blockquote><p><strong>Why Bind Variables Are Useful</strong></p><p>
Why bother with bind variables at all - why not just write the Tcl statement
above like this: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_dml presentation_delete "
    delete from wp_presentations where presentation_id = $some_presentation_id
"

</pre></td></tr></table></blockquote><p>
(Note the use of double-quotes to allow the variable reference to
<tt>$some_presentation_id</tt> to be interpolated in.) This will work,
but consider the case where some devious user causes
<tt>some_presentation_id</tt> to be set to something like <tt>'3 or
1 = 1'</tt>, which would result in the following statement being
executed: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

delete from wp_presentations where presentation_id = 3 or 1 = 1

</pre></td></tr></table></blockquote><p>
This deletes every presentation in the database! Using bind variables
eliminates this gaping security hole: since bind variable values are taken
literally. Oracle will attempt to delete presentations whose presentation ID
is literally <tt>'3 or 1 = 1'</tt> (i.e., no presentations, since
<tt>'3 or 1 = 1'</tt> can't possibly be a valid integer
primary key for <tt>wp_presentations</tt>. In general, since Oracle
always considers the values of bind variables to be literals, it becomes more
difficult for users to perform URL surgery to trick scripts into running
dangerous queries and DML. 
</p><p><strong>Usage</strong></p><p>Every <tt>db_*</tt> command accepting a SQL command as an argument
supports bind variables. You can either</p><div class="itemizedlist"><ul><li><a name="N19782"></a><p>specify the <tt>-bind</tt> switch to provide a set with bind variable
values, or</p></li><li><a name="N19789"></a><p>specify the <tt>-bind</tt> switch to explicitly provide a list of
bind variable names and values, or</p></li><li><a name="N19796"></a><p>not specify a bind variable list at all, in which case Tcl variables are
used as bind variables.</p></li></ul></div><p>
The default behavior (i.e., if the <tt>-bind</tt> switch is omitted) is
that these procedures expect to find local variables that correspond in name
to the referenced bind variables, e.g.: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

set user_id 123456
set role "administrator"

db_foreach user_group_memberships_by_role {
    select g.group_id, g.group_name
    from user_groups g, user_group_map map
    where g.group_id = map.user_id
    and map.user_id = :user_id
    and map.role = :role
} {
    # do something for each group of which user 123456 is in the role
    # of "administrator"
}

</pre></td></tr></table></blockquote><p>
The value of the local Tcl variable <tt>user_id</tt> (123456) is bound to
the <tt>user_id</tt> bind variable. 
</p><p>The <tt>-bind</tt> switch can takes the name of an <tt>ns_set</tt>
containing keys for each bind variable named in the query, e.g.:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

set bind_vars [ns_set create]
ns_set put $bind_vars user_id 123456
ns_set put $bind_vars role "administrator"

db_foreach user_group_memberships_by_role {
    select g.group_id, g.group_name
    from user_groups g, user_group_map map
    where g.group_id = map.user_id
    and map.user_id = :user_id
    and map.role = :role
} -bind $bind_vars {
    # do something for each group in which user 123456 has the role
    # of "administrator"
}

</pre></td></tr></table></blockquote><p>
Alternatively, as an argument to <tt>-bind</tt> you can specify a list of
alternating name/value pairs for bind variables: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_foreach user_group_memberships_by_role {
    select g.group_id, g.group_name
    from user_groups g, user_group_map map
    where g.group_id = map.user_id
    and map.user_id = :user_id
    and map.role = :role
} -bind [list user_id 123456 role "administrator"] {
    # do something for each group in which user 123456 has the role
    # of "administrator"
}

</pre></td></tr></table></blockquote><p><strong><a name="dbapi_nulls_and_bind_vars"></a>Nulls and Bind Variables</strong></p><p>
When processing a DML statement, Oracle coerces empty strings into
<tt>null</tt>. (This coercion does <i>not</i> occur in the
<tt>WHERE</tt> clause of a query, i.e.
<tt>col&nbsp;=&nbsp;''</tt> and
<tt>col&nbsp;is&nbsp;null</tt> are not equivalent.) 
</p><p>As a result, when using bind variables, the only way to make Oracle set a
column value to <tt>null</tt> is to set the corresponding bind variable
to the empty string, since a bind variable whose value is the string
"null" will be interpreted as the literal string
"null".</p><p>These Oracle quirks complicate the process of writing clear and abstract
DML difficult. Here is an example that illustrates why:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

#
# Given the table:
#
#   create table foo (
#           bar        integer,
#           baz        varchar(10)
#   );
#

set bar ""
set baz ""

db_dml foo_create "insert into foo(bar, baz) values(:bar, :baz)"
#
# the values of the "bar" and "baz" columns in the new row are both
# null, because Oracle has coerced the empty string (even for the
# numeric column "bar") into null in both cases

</pre></td></tr></table></blockquote><p>
Since databases other than Oracle do not coerce empty strings into
<tt>null</tt>, this code has different semantics depending on the
underlying database (i.e., the row that gets inserted may not have null as
its column values), which defeats the purpose of SQL abstraction. 
</p><p>Therefore, the Database Access API provides a database-independent way to
represent <tt>null</tt> (instead of the Oracle-specific idiom of the
empty string): <strong><tt>db_null</tt></strong>.</p><p>Use it instead of the empty string whenever you want to set a column value
explicitly to <tt>null</tt>, e.g.:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

set bar [db_null]
set baz [db_null]

db_dml foo_create "insert into foo(bar, baz) values(:bar, :baz)"
#
# sets the values for both the "bar" and "baz" columns to null

</pre></td></tr></table></blockquote></div><div id="db-api-detailed-sql-abstraction" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-sql-abstraction"></a><span class="label">17.5.</span> <span class="title">SQL Abstraction</span></h3></div><p>
We now require that each SQL statement be assigned a logical name for the
statement that is unique to the procedure or page in which it is defined.
This is so that (eventually) we can implement logically named statements with
alternative SQL for non-Oracle databases (e.g., Postgres). More on this
later. 
</p></div><div id="db-api-detailed-placing-values" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-placing-values"></a><span class="label">17.6.</span> <span class="title">Placing Column Values in Arrays and Sets</span></h3></div><p>
Normally, <tt>db_foreach</tt>, <tt>db_0or1row</tt>, and
<tt>db_1row</tt> places the results of queries in Tcl variables, so you
can say: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_foreach users_select "select first_names, last_name from users" {
    doc_body_append "&lt;li&gt;$first_names $last_name\n"
}

</pre></td></tr></table></blockquote><p>
However, sometimes this is not sufficient: you may need to examine the rows
returned, to dynamically determine the set of columns returned by the query,
or to avoid collisions with existing variables. You can use the
<tt>-column_array</tt> and <tt>-column_set</tt> switches to
<tt>db_foreach</tt>, <tt>db_0or1row</tt>, and <tt>db_1row</tt> to
instruct the database routines to place the results in a Tcl array or
<tt>ns_set</tt>, respectively, where the keys are the column names and
the values are the column values. For example: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_foreach users_select "select first_names, last_name from users" -column_set columns {
    # Now $columns is an ns_set.
    doc_body_append "&lt;li&gt;"
    for { set i 0 } { $i &lt; [ns_set size $columns] } { incr i } {
        doc_body_append "[ns_set key $columns $i] is [ns_set value $columns $i]. \n"
    }
}

</pre></td></tr></table></blockquote><p>
will write something like: 
</p><div class="itemizedlist"><ul><li><a name="N19962"></a><p>first_names is Jon. last_name is Salz.</p></li><li><a name="N19965"></a><p>first_names is Lars. last_name is Pind.</p></li><li><a name="N19968"></a><p>first_names is Michael. last_name is Yoon.</p></li></ul></div></div><div id="db-api-detailed-pooling" class="sect2"><div class="titlepage"><h3 class="title"><a name="db-api-detailed-pooling"></a><span class="label">17.7.</span> <span class="title">Sequence Pooling</span></h3></div><p>
The database library can transparently maintain pools of sequence values, so
that each request for a new sequence value (using <tt>db_nextval</tt>)
does not incur a roundtrip to the server. For instance, this functionality is
very useful in the security/sessions library, which very frequently allocates
values from the <tt>sec_id_seq</tt> sequence. To utilize this
functionality for a particular sequence, register the sequence to be pooled,
either using the <tt>db_register_pooled_sequence</tt> procedure at server
startup time, or by including a configuration parameter of the form 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

PoolSequence.<i>sequence_name_seq</i>=<i>count</i>

</pre></td></tr></table></blockquote><p>
in <i>any</i> configuration section in the <tt>yourservername.ini</tt>
file, e.g., e.g., 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

[ns/server/<i>yourservername</i>/acs/security]
PoolSequence.sec_id_seq=20

</pre></td></tr></table></blockquote><p>
The database library will allocate this number of sequence values at server
startup. It will periodically scan pools and allocate new values for
sequences which are less than half-full. (This normally occurs every 60
seconds, and is configurable via the
<tt>PooledSequenceUpdateInterval</tt> parameter in the
<tt>[ns/server/</tt><i><tt>yourservername</tt></i><tt>/acs/database]</tt> configuration
section.) 
</p></div><div id="dp-api-detailed-api" class="sect2"><div class="titlepage"><h3 class="title"><a name="dp-api-detailed-api"></a><span class="label">17.8.</span> <span class="title">API</span></h3></div><p>
Note that you never have to use <tt>ns_db</tt> anymore (including
<tt>ns_db gethandle</tt>)! Just start doing stuff, and (if you want) call
<tt>db_release_unused_handles</tt> when you're done as a hint to
release the database handle. 
</p><div class="variablelist"><dl><dt><a name="N20050"></a><span class="term"><strong><tt><a name="dbapi_db_abort_transaction"></a>db_abort_transaction</tt></strong>
</span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_abort_transaction</strong>
</pre></td></tr></table></blockquote><p>Aborts all levels of a transaction. That is if this is called within
several nested transactions, all of them are terminated. Use this insetead of
<tt>db_dml "abort" "abort transaction"</tt>. 


</p></dd><dt><a name="N20072"></a><span class="term"><strong><tt><a name="dbapi_db_null"></a>db_null</tt></strong>

</span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong><tt>db_null</tt></strong>
</pre></td></tr></table></blockquote><p>Returns a value which can be used in a bind variable to represent the SQL
value <tt>null</tt>. See <a href="db-api-detailed.html#dbapi_nulls_and_bind_vars">Nulls and Bind Variables</a>
above.</p></dd><dt><a name="N20100"></a><span class="term">
<strong><tt><a name="dbapi_db_foreach"></a>db_foreach</tt></strong>
</span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_foreach</strong> <i>statement-name sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ] \
    [ -column_array <i>array_name</i> | -column_set <i>set_name</i> ] \
    <i>code_block</i> [ if_no_rows <i>if_no_rows_block ]</i>
</pre></td></tr></table></blockquote><p>Performs the SQL query <i><tt>sql</tt></i>, executing
<i><tt>code_block</tt></i> once for each row with variables set to
column values (or a set or array populated if <tt>-column_array</tt> or
<tt>column_set</tt> is specified). If the query returns no rows, executes
<i><tt>if_no_rows_block</tt></i> (if provided). </p><p>Example:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_foreach select_foo "select foo, bar from greeble" {
    doc_body_append "&lt;li&gt;foo=$foo; bar=$bar\n"
} if_no_rows {
    doc_body_append "&lt;li&gt;There are no greebles in the database.\n"
}

</pre></td></tr></table></blockquote><p>
The code block may contain <tt>break</tt> statements (which terminate the
loop and flush the database handle) and <tt>continue</tt> statements
(which continue to the next row of the loop). </p></dd><dt><a name="N20178"></a><span class="term"><strong><tt><a name="dbapi_db_1row"></a>db_1row</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_1row</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ] \
    [ -column_array <i>array_name</i> | -column_set <i>set_name</i> ]
</pre></td></tr></table></blockquote><p>Performs the SQL query <i><tt>sql</tt></i>, setting variables to
column values. Raises an error if the query does not return exactly 1 row. </p><p>Example:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_1row select_foo "select foo, bar from greeble where greeble_id = $greeble_id"
# Bombs if there's no such greeble!
# Now $foo and $bar are set.

</pre></td></tr></table></blockquote></dd><dt><a name="N20223"></a><span class="term"><strong><tt><a name="dbapi_db_0or1row"></a>db_0or1row</tt></strong> </span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_0or1row</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ] \
    [ -column_array <i>array_name</i> | -column_set <i>set_name</i> ]
</pre></td></tr></table></blockquote><p>Performs the SQL query <i><tt>sql</tt></i>. If a row is returned,
sets variables to column values and returns 1. If no rows are returned,
returns 0. If more than one row is returned, throws an error. </p></dd><dt><a name="N20264"></a><span class="term"><strong><tt><a name="dbapi_db_nextval"></a>db_nextval</tt></strong> </span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_nextval</strong> <i>sequence-name</i>
</pre></td></tr></table></blockquote><p>Returns the next value for the sequence <i>sequence-name</i> (using a
SQL statement like <tt>SELECT</tt> <i><tt>sequence-name</tt></i><tt>.nextval FROM
DUAL</tt>). If sequence pooling is enabled for the sequence, transparently
uses a value from the pool if available to save a round-trip to the database
(see <i><a href="db-api-detailed.html#db-api-detailed-pooling">Sequence Pooling</a></i>). 

</p></dd><dt><a name="N20304"></a><span class="term"><strong><tt><a name="dbapi_db_register_pooled_sequence"></a>db_register_pooled_sequence</tt></strong> </span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_register_pooled_sequence</strong> <i>sequence-name</i> <i>pool-size</i>
</pre></td></tr></table></blockquote><p>Registers the sequence <i>sequence-name</i> to be pooled, with a pool
size of <i>pool-size</i> sequence values (see <i><a href="db-api-detailed.html#db-api-detailed-pooling">Sequence Pooling</a></i>). 

</p></dd><dt><a name="N20338"></a><span class="term"><strong><tt><a name="dbapi_db_string"></a>db_string</tt></strong> </span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_string</strong> <i>statement-name</i> <i>sql</i> [ -default <i>default</i> ] [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ]
</pre></td></tr></table></blockquote><p>Returns the first column of the result of SQL query
<i><tt>sql</tt></i>. If <i><tt>sql</tt></i> doesn't return a
row, returns <i><tt>default</tt></i> (or throws an error if
<i><tt>default</tt></i> is unspecified). Analogous to
<tt>database_to_tcl_string</tt> and
<tt>database_to_tcl_string_or_null</tt>. 

</p></dd><dt><a name="N20399"></a><span class="term"><strong><tt><a name="dbapi_db_list"></a>db_list</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_list</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ]
</pre></td></tr></table></blockquote><p>Returns a Tcl list of the values in the first column of the result of SQL
query <i><tt>sql</tt></i>. If <i><tt>sql</tt></i> doesn't
return any rows, returns an empty list. Analogous to
<tt>database_to_tcl_list</tt>. 

</p></dd><dt><a name="N20442"></a><span class="term"><strong><tt><a name="dbapi_db_list_of_lists"></a>db_list_of_lists</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_list_of_lists</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ]
</pre></td></tr></table></blockquote><p>Returns a Tcl list, each element of which is a list of all column values
in a row of the result of SQL query <i><tt>sql</tt></i>. If
<i><tt>sql</tt></i> doesn't return any rows, returns an empty list.
(Analogous to <tt>database_to_tcl_list_list</tt>.) 

</p></dd><dt><a name="N20485"></a><span class="term"><strong><tt><a name="dbapi_db_dml"></a>db_dml</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_dml</strong> <i>statement-name</i> <i>sql</i> \
    [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ] \
    [ -blobs <i>blob_list</i> | -clobs <i>clob_list</i> |
      -blob_files <i>blob_file_list</i> | -clob_files <i>clob_file_list</i> ]
</pre></td></tr></table></blockquote><p>Performs the DML or DDL statement <i><tt>sql</tt></i>. </p><p>If a length-<i>n</i> list of blobs or clobs is provided, then the SQL
should return <i>n</i> blobs or clobs into the bind variables
<tt>:1</tt>, <tt>:2</tt>, ... :<i><tt>n</tt></i>.
<i><tt>blobs</tt></i> or <i><tt>clobs</tt></i>, if specified,
should be a list of individual BLOBs or CLOBs to insert;
<i><tt>blob_files</tt></i> or <i><tt>clob_files</tt></i>, if
specified, should be a list of <i>paths to files</i> containing the data to
insert. Only one of <tt>-blobs</tt>, <tt>-clobs</tt>,
<tt>-blob_files</tt>, and <tt>-clob_files</tt> may be provided.</p><p>Example:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_dml insert_photos "
        insert photos(photo_id, image, thumbnail_image)
        values(photo_id_seq.nextval, empty_blob(), empty_blob())
        returning image, thumbnail_image into :1, :2
    "  -blob_files [list "/var/tmp/the_photo" "/var/tmp/the_thumbnail"] 

</pre></td></tr></table></blockquote><p>
This inserts a new row into the <tt>photos</tt> table, with the contents
of the files <tt>/var/tmp/the_photo</tt> and
<tt>/var/tmp/the_thumbnail</tt> in the <tt>image</tt> and
<tt>thumbnail</tt> columns, respectively. 


</p></dd><dt><a name="N20618"></a><span class="term">
<strong><tt><a name="dbapi_db_write_clob"></a>db_write_clob</tt></strong>,
<strong><tt><a name="dbapi_db_write_blob"></a>db_write_blob</tt></strong>,
<strong><tt><a name="dbapi_db_blob_get_file"></a>db_blob_get_file</tt></strong>
</span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_write_clob</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ]

<strong>db_write_blob</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ]

<strong>db_blob_get_file</strong> <i>statement-name</i> <i>sql</i> [ -bind <i>bind_set_id</i> | -bind <i>bind_value_list</i> ]
</pre></td></tr></table></blockquote><p>Analagous to <tt>ns_ora write_clob/write_blob/blob_get_file</tt>. 


</p></dd><dt><a name="N20697"></a><span class="term"><strong><tt><a name="dbapi_db_release_unused_handles"></a>db_release_unused_handles</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_release_unused_handles</strong>
</pre></td></tr></table></blockquote><p>Releases any allocated, unused database handles. </p></dd><dt><a name="N20714"></a><span class="term"><strong><tt><a name="dbapi_db_transaction"></a>db_transaction</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_transaction</strong> <i>code_block</i> [ on_error { <i>code_block</i> } ]
</pre></td></tr></table></blockquote><p>Executes <i><tt>code_block</tt></i> transactionally. Nested
transactions are supported (<tt>end transaction</tt> is transparently
<tt>ns_db dml</tt>'ed when the outermost transaction completes). The
<tt>db_abort_transaction</tt> command can be used to abort all levels of
transactions. It is possible to specify an optional <tt>on_error</tt>
code block that will be executed if some code in <i>code_block</i> throws
an exception. The variable <tt>errmsg</tt> will be bound in that scope.
If there is no <tt>on_error</tt> code, any errors will be propagated. </p><p>Example:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

proc replace_the_foo { col } {
    db_transaction {
        db_dml "delete from foo"
        db_dml "insert into foo(col) values($col)"
    }
}

proc print_the_foo {} {
    doc_body_append "foo is [db_string "select col from foo"]&lt;br&gt;\n"
}

replace_the_foo 8
print_the_foo ; # Writes out "foo is 8"

db_transaction {
    replace_the_foo 14
    print_the_foo ; # Writes out "foo is 14"
    db_dml "insert into some_other_table(col) values(999)"
    ...
    db_abort_transaction
} on_error {
    doc_body_append "Error in transaction: $errmsg"
}
    

print_the_foo ; # Writes out "foo is 8"

</pre></td></tr></table></blockquote></dd><dt><a name="N20774"></a><span class="term"><strong><tt><a name="dbapi_db_resultrows"></a>db_resultrows</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_resultrows</strong>
</pre></td></tr></table></blockquote><p>Returns the number of rows affected or returned by the previous
statement. 


</p></dd><dt><a name="N20791"></a><span class="term"><strong><tt><a name="dbapi_db_with_handle"></a>db_with_handle</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_with_handle</strong> <i>var</i> <i>code_block</i>
</pre></td></tr></table></blockquote><p>Places a database handle into the variable <i><tt>var</tt></i> and
executes <i><tt>code_block</tt></i>. This is useful when you don't
want to have to use the new API (<tt>db_foreach</tt>,
<tt>db_1row</tt>, etc.), but need to use database handles explicitly. </p><p>Example:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

proc lookup_the_foo { foo } {
    db_with_handle db {
        return [db_string unused "select ..."]
    }
}

db_with_handle db {
    # Now there's a database handle in $db.
    set selection [ns_db select $db "select foo from bar"]
    while { [ns_db getrow $db $selection] } {
        set_variables_after_query

        lookup_the_foo $foo
    }
}

</pre></td></tr></table></blockquote></dd><dt><a name="N20837"></a><span class="term"><strong><tt><a name="dbapi_db_nullify_empty_string"></a>db_nullify_empty_string</tt></strong></span></dt><dd><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>
<strong>db_nullify_empty_string</strong> <i>string</i>
</pre></td></tr></table></blockquote><p>For true SQL purists, we provide the convenience function
<strong><tt>db_nullify_empty_string</tt></strong>, which returns
[db_null] if its <i><tt>string</tt></i> argument is the empty string
and can be used to encapsulate another Oracle quirk: </p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

set baz ""

# Clean out the foo table
#
db_dml unused "delete from foo"

db_dml unused "insert into foo(baz) values('$baz')"

set n_rows [db_string unused "select count(*) from foo where baz is null"]
#
# $n_rows is 1; in effect, the "baz is null" criterion is matching
# the empty string we just inserted (because of Oracle's coercion
# quirk)

</pre></td></tr></table></blockquote><p>
To balance out this asymmetry, you can explicitly set <tt>baz</tt> to
<tt>null</tt> by writing: 
</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_dml foo_insert "insert into foo(baz) values(:1)" {[db_nullify_empty_string $baz]}

</pre></td></tr></table></blockquote></dd></dl></div><p><strong>Implementation Design (work in progress)</strong></p><p>
<i>The ideas here are preliminary, so please send feedback to <a href="mailto:michael@arsdigita.com" target="_top">michael@arsdigita.com</a>. There may well
be a much simpler, superior design that I (Michael) am just missing right
now. If so, please let me know!</i> 
</p><p>The basic idea is to translate the logical
<i><tt>statement-name</tt></i> into an actual SQL statement, written in
the appropriate SQL dialect for the RDBMS that is in use. The
<i><tt>sql</tt></i> argument is essentially a convenience that enables
the SQL for the "default dialect" to be written inline. For 3.4, we
will probably use configuration parameters to tell the Database Access API
what the default dialect is and what dialect is actually in use:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

[ns/server/<i>server_name</i>/acs]
...
DefaultSQLDialect=oracle8
SQLDialect=postgres7

</pre></td></tr></table></blockquote><p>
(An alternative approach would be to use the ACS Package Manager, i.e.,
install a "pseudo-package" with no actual code to indicate what
RDBMS is installed. Then, the Database Access API could query the APM to
figure what SQL dialect to employ.) 
</p><p>For instructing the Database Access API to translate a named statement in
a specific SQL dialect, we may define a new API call:</p><blockquote><table border="0" cellpadding="5" cellspacing="0"><tr><td class="codeblock"><pre>

db_implement_statement <i>statement_location</i> <i>statement_name</i> <i>sql_dialect</i> <i>sql</i>

</pre></td></tr></table></blockquote><p>
which would be called at server initialization time. The Database Access API
will then know to use the SQL statement appropriate for the specified
<tt>SQLDialect</tt>. (The name <tt>db_implement_statement</tt> is
very tentative.) </p><p>Issues:</p><div class="itemizedlist"><ul><li><a name="N20945"></a><p>Is making the caller of <tt>db_implement_statement</tt> explicitly
specify the statement location (e.g., "/bboard/q-and-a") too much
of a pain? Can we make this more convenient somehow? 


</p></li><li><a name="N20952"></a><p>In the case that the inline SQL is not in the specified
<tt>SQLDialect</tt>, reading the rewritten SQL into memory for the life
of the server may not be a good idea. The three basic approaches I can think
of to implement the <tt>db_implement_statement</tt> API are: </p><div class="orderedlist"><ol type="1"><li><a name="N20966"></a><p>Cache the rewritten SQL for the appropriate SQL dialect in an
<tt>nsv</tt> array</p></li><li><a name="N20973"></a><p>Cache the rewritten SQL for the appropriate SQL dialect in a special
database table that we keep pinned in memory</p></li><li><a name="N20976"></a><p>Cache the rewritten SQL for the appropriate SQL dialect in a special
file, maybe even a DBM file</p></li></ol></div></li><li><a name="N20979"></a><p>Given the above two issues, should we rethink the
<tt>db_implement_statement</tt> API altogether? </p><p>One possibility is a file-based approach, where the alternative SQL
statements would live in conventionally named and located files, e.g.,
<tt>/bboard/q-and-a.postgres7</tt> would contain Postgres 7 versions of
the SQL statements in <tt>/bboard/q-and-a.tcl</tt>.) A potential con of
this approach is that the Database Access API would have to perform file I/O
for every SQL statement that's been rewritten. This may be a non-issue; I
don't actually know. (We could augment this approach with caching too,
perhaps a fixed-size LRU cache.)</p><p>Another similar approach would be just to have one massive, magic file for
each SQL dialect that maps each statement identifier (location plus name) to
the corresponding statement.</p></li><li><a name="N20998"></a><p>Another larger problem is the fact that this design does not work for
instances where we build a SQL statement based on control flow logic, e.g.,
we sometimes join in an extra table based on the user input. This problem
doesn't mean that the design as a whole is broken; it just means that
this design alone does not get us all the way to full SQL abstraction.</p></li></ul></div><p>
Version 2.1 of <a href="http://www.openacs.org/free-tools/oracle-driver" target="_top">the ArsDigita Oracle
Driver</a> adds a set of <tt>ns_ora</tt> analogs for the following
<tt>ns_db</tt> calls: <tt>0or1row</tt>, <tt>1row</tt>,
<tt>select</tt>, and <tt>dml</tt>. (It also adds <tt>ns_ora
array_dml</tt>.) Thus, the groundwork for implementing the above API for
ACS/Oracle is already established. </p><p>We plan to defer to the OpenACS team for the Postgres implementation of
the API.</p><p><div align="right" class="cvstag">($Id$)</div></p></div></div><div class="navfooter"><hr size="1" noshade><table width="100%"><tr><td width="40%" align="left"><a class="bottomnav" href="rp-design.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a href="mailto:acs-docs@arsdigita.com"><address class="nav">acs-docs@arsdigita.com</address></a></td><td width="40%" align="right">&nbsp;<a class="bottomnav" href="tcl-doc.html">Next</a></td></tr></table></div></body></html>
